(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{787:function(t,a,e){"use strict";e.r(a);var s=e(12),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[t._v("#")]),t._v(" Set")]),t._v(" "),e("h3",{attrs:{id:"特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),e("p",[e("code",[t._v("Set")]),t._v(" 数据结构类似于数组，但是其成员的值都是唯一的，没有重复的值，可用于去重字符串和数组")]),t._v(" "),e("p",[e("code",[t._v("Set")]),t._v(" 构造函数可接收一个数组活具有 "),e("code",[t._v("iterable接口")]),t._v(" 的其他数据结构作为参数进行初始化")]),t._v(" "),e("p",[t._v("向 "),e("code",[t._v("Set")]),t._v(" 加入值的时候不会发生类型转换，所以 "),e("code",[t._v("5")]),t._v(" 和 "),e("code",[t._v("'5'")]),t._v(" 是两个不同的值，"),e("code",[t._v("Set")]),t._v(" 内的相等判断类似 "),e("code",[t._v("===")]),t._v(" ，区别在于 "),e("code",[t._v("Set")]),t._v(" 认为 "),e("code",[t._v("NaN")]),t._v(" 等于自身")]),t._v(" "),e("h3",{attrs:{id:"实例方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例方法"}},[t._v("#")]),t._v(" 实例方法")]),t._v(" "),e("p",[e("code",[t._v("Set.prototype.add(value)")]),t._v(" 添加某个值，返回 Set 结构本身\n"),e("code",[t._v("Set.prototype.delete(value)")]),t._v(" 删除某个值，返回一个布尔值，表示删除是否成功\n"),e("code",[t._v("Set.prototype.has(value)")]),t._v(" 返回一个布尔值，表示该值是否为 Set 的成员\n"),e("code",[t._v("Set.prototype.clear()")]),t._v(" 清除所有成员，没有返回值\n"),e("code",[t._v("Set.prototype.keys()")]),t._v(" 返回键名的遍历器， set 结构没有键名，或者说是键名和键值是同一个值，所以 keys 和 values 方法的行为完全一致\n"),e("code",[t._v("Set.prototype.values()")]),t._v(" 返回键值的遍历器\n"),e("code",[t._v("Set.prototype.entries()")]),t._v(" 返回键值对的遍历器\n"),e("code",[t._v("Set.prototype.forEach()")]),t._v(" 使用回调函数遍历每个成员，与数组的 forEach 方法相同")]),t._v(" "),e("h3",{attrs:{id:"实例属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例属性"}},[t._v("#")]),t._v(" 实例属性")]),t._v(" "),e("p",[e("code",[t._v("Set.prototype.size")]),t._v(" 返回 Set 实例的成员总数。")]),t._v(" "),e("h2",{attrs:{id:"weakset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#weakset"}},[t._v("#")]),t._v(" WeakSet")]),t._v(" "),e("p",[e("code",[t._v("WeakSet")]),t._v(" 与 "),e("code",[t._v("Set")]),t._v(" 类似")]),t._v(" "),e("h3",{attrs:{id:"与-set-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与-set-的区别"}},[t._v("#")]),t._v(" 与 Set 的区别")]),t._v(" "),e("p",[e("code",[t._v("WeakSet")]),t._v(" 的成员只能是"),e("strong",[t._v("对象")]),t._v("，不能是其他类型的值\n"),e("code",[t._v("WeakSet")]),t._v(" 中的对象都是弱引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存\nES6 规定 "),e("code",[t._v("WeakSet")]),t._v(" 不可遍历")]),t._v(" "),e("h2",{attrs:{id:"map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[t._v("#")]),t._v(" Map")]),t._v(" "),e("p",[t._v("传统的对象只接收字符串作为键名，非字符串会被自动转换，"),e("code",[t._v("Map")]),t._v(" 可以接收所有类型的值当做键")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" m "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Map")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"name"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"zkb"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"title"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"gg"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构造函数可接收一个数组作为参数，数组的成员是一个个表示键值对的数组")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" m1 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Map")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"name"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"zkb"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"title"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"gg"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 利用Set来生成新的Map，任何具有iterator接口且每个成员都是双元素的数组的数据结构都可作为Map构造函数的参数")]),t._v("\n")])])]),e("h3",{attrs:{id:"特性-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特性-2"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),e("p",[t._v("只有对同一个对象的引用 "),e("code",[t._v("Map")]),t._v(" 才将其视为同一个键")]),t._v(" "),e("p",[e("code",[t._v("undefined")]),t._v(" 和 "),e("code",[t._v("null")]),t._v(" 是两个不同的键，虽然 "),e("code",[t._v("NaN")]),t._v(" 不严格等于自身，但 "),e("code",[t._v("Map")]),t._v(" 将其视为同一个键")]),t._v(" "),e("h3",{attrs:{id:"实例方法-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例方法-2"}},[t._v("#")]),t._v(" 实例方法")]),t._v(" "),e("p",[e("code",[t._v("Map.prototype.set(key,value)")]),t._v(" 设置键名 key 对应的值 value，然后返回整个 Map 结构，如果 key 已经有值则覆盖，没有则新建\n"),e("code",[t._v("Map.prototype.get(key)")]),t._v(" 读取 key 对应的键值，找不到 key 则返回 undefined\n"),e("code",[t._v("Map.prototype.has(key)")]),t._v(" 返回一个布尔值，表示某个键是否在当前 Map 对象中\n"),e("code",[t._v("Map.prototype.delete(key)")]),t._v(" 删除某个键，成功返回 true，失败返回 false\n"),e("code",[t._v("Map.prototype.clear()")]),t._v(" 清除所有成员，没有返回值\n"),e("code",[t._v("Map.prototype.keys()")]),t._v(" 返回键名的遍历器。\n"),e("code",[t._v("Map.prototype.values()")]),t._v(" 返回键值的遍历器。\n"),e("code",[t._v("Map.prototype.entries()")]),t._v(" 返回所有成员的遍历器。\n"),e("code",[t._v("Map.prototype.forEach()")]),t._v(" 遍历 Map 的所有成员。")]),t._v(" "),e("h2",{attrs:{id:"weakmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#weakmap"}},[t._v("#")]),t._v(" WeakMap")]),t._v(" "),e("p",[e("code",[t._v("WeakMap")]),t._v(" 与 "),e("code",[t._v("Map")]),t._v(" 类似")]),t._v(" "),e("h3",{attrs:{id:"与-map-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与-map-的区别"}},[t._v("#")]),t._v(" 与 Map 的区别")]),t._v(" "),e("p",[t._v("只接收对象作为键名（null 除外），不接受其他类型的值作为键名， WeakMap 的键名所指向的对象不计入垃圾回收机制")])])}),[],!1,null,null,null);a.default=n.exports}}]);