(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{797:function(t,s,a){"use strict";a.r(s);var r=a(12),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"react-元素是不可变对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-元素是不可变对象"}},[t._v("#")]),t._v(" React 元素是不可变对象")]),t._v(" "),a("p",[t._v("一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render()。")]),t._v(" "),a("h2",{attrs:{id:"组件名称必须以大写字母开头"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件名称必须以大写字母开头"}},[t._v("#")]),t._v(" 组件名称必须以大写字母开头")]),t._v(" "),a("p",[t._v("React 会将以小写字母开头的组件视为原生 DOM 标签。")]),t._v(" "),a("h2",{attrs:{id:"无法修改自身-props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无法修改自身-props"}},[t._v("#")]),t._v(" 无法修改自身 props")]),t._v(" "),a("p",[t._v("组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。所有 React 组件都必须像纯函数（状态机，不尝试更改入参，多次调用时相同的入参始终返回相同的结果）一样保护它们的 props 不被更改。")]),t._v(" "),a("h2",{attrs:{id:"class-组件应该始终使用-props-参数来调用父类的构造函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-组件应该始终使用-props-参数来调用父类的构造函数"}},[t._v("#")]),t._v(" Class 组件应该始终使用 "),a("code",[t._v("props")]),t._v(" 参数来调用父类的构造函数")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Clock")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#赋值"}},[t._v("#")]),t._v(" 赋值")]),t._v(" "),a("p",[t._v("构造函数是唯一可以给 "),a("code",[t._v("this.state")]),t._v(" 赋值的地方")]),t._v(" "),a("h2",{attrs:{id:"没有插槽"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#没有插槽"}},[t._v("#")]),t._v(" 没有插槽")]),t._v(" "),a("p",[t._v("React 中没有“插槽（slot）”这一概念的限制，你可以将任何东西作为 props 进行传递。")])])}),[],!1,null,null,null);s.default=e.exports}}]);