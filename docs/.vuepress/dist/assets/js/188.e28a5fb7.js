(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{842:function(v,_,t){"use strict";t.r(_);var e=t(12),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"封闭局部变量不会导致内存泄漏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封闭局部变量不会导致内存泄漏"}},[v._v("#")]),v._v(" 封闭局部变量不会导致内存泄漏")]),v._v(" "),t("p",[v._v("闭包是一个非常强大的特性，但人们对其也有诸多误解。一种耸人听闻的说法是闭包会造成内存泄露，所以要尽量减少闭包的使用。")]),v._v(" "),t("p",[v._v("局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。")]),v._v(" "),t("p",[v._v("使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，"),t("strong",[v._v("把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的")]),v._v("，这里并不能说成是内存泄露。")]),v._v(" "),t("h2",{attrs:{id:"造成内存泄露的真正原因-引用计数策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#造成内存泄露的真正原因-引用计数策略"}},[v._v("#")]),v._v(" 造成内存泄露的真正原因：引用计数策略")]),v._v(" "),t("p",[v._v("闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 "),t("code",[v._v("DOM 节点")]),v._v("，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 "),t("code",[v._v("JavaScript")]),v._v(" 的问题。")]),v._v(" "),t("p",[v._v("在 "),t("code",[v._v("IE 浏览器")]),v._v("中，由于 "),t("code",[v._v("BOM")]),v._v(" 和 "),t("code",[v._v("DOM")]),v._v(" 中的对象是使用 "),t("code",[v._v("C++")]),v._v(" 以 "),t("code",[v._v("COM 对象")]),v._v(" 的方式实现的，而 "),t("code",[v._v("COM 对象")]),v._v(" 的垃圾收集机制采用的是引用计数策略。")]),v._v(" "),t("p",[v._v("在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。")]),v._v(" "),t("p",[v._v("如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 "),t("code",[v._v("null")]),v._v(" 即可。将变量设置为 "),t("code",[v._v("null")]),v._v(" 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。")]),v._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),t("p",[v._v("JavaScript 设计模式与开发实践")])])}),[],!1,null,null,null);_.default=a.exports}}]);