(window.webpackJsonp=window.webpackJsonp||[]).push([[271],{921:function(a,e,t){"use strict";t.r(e);var r=t(12),i=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[a._v("#")]),a._v(" 场景")]),a._v(" "),t("p",[a._v("可以在离线情况下访问的网站大概可以分为两类，一类是“可以离线使用”的网站，他们的主要逻辑在客户端实现，服务端只提供一些数据；而另一类则是“可以离线查看”的网站，这些网站的主要逻辑在服务端实现。")]),a._v(" "),t("h2",{attrs:{id:"方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方案"}},[a._v("#")]),a._v(" 方案")]),a._v(" "),t("h3",{attrs:{id:"serviceworker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#serviceworker"}},[a._v("#")]),a._v(" ServiceWorker")]),a._v(" "),t("p",[a._v("一个特殊的 worker 线程，相当于服务器和浏览器之间的中间件，注册了 Service Worker 的网站，Service Worker 可以拦截这个网站的请求，根据代码来判断要执行的缓存策略和使用缓存的策略。")]),a._v(" "),t("h3",{attrs:{id:"applicationcache-manifest"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#applicationcache-manifest"}},[a._v("#")]),a._v(" ApplicationCache(manifest)")]),a._v(" "),t("p",[a._v("即 Application cache，ServiceWorker 之前的缓存解决方案，目前已废弃。")]),a._v(" "),t("p",[a._v("即使在线，文件也从 ApplicationCache 中加载，在 ServiceWorker 中这是可以自行决定的。")]),a._v(" "),t("p",[a._v("ApplicationCache 只在 Manifest 文件改变的时候更新。如果在你的 manifest 中有 50 个 html 页面，每次你在线的情况下访问他们的时候，浏览器会创建 50 个网络请求来确认他们是不是需要更新。manifest 文件比较是以二进制方式进行的。")]),a._v(" "),t("p",[a._v("更新 manifaset 文件路径，用户再访问页面时，他们会获取 ApplicationCache 的版本，如果已经更改了 manifest 文件地址的话，很不幸的，用户缓存的版本依然指向旧的 manifest 文件，它就永远不会更新了，永远。")]),a._v(" "),t("p",[a._v("ApplicationCache 的规则更像是一个洋葱，它有很多很多层，随着你慢慢剥开它，眼泪也会慢慢流下来。")]),a._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),t("p",[t("a",{attrs:{href:"http://zoomzhao.github.io/2012/11/11/application-cache-is-a-douchebag/",target:"_blank",rel:"noopener noreferrer"}},[a._v("ApplicationCache 是个坑"),t("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=i.exports}}]);