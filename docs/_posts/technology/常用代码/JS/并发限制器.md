---
date: 2021-12-10 16:07:24
title: 并发限制器
tags:
  - 常用代码
  - JS
---

同时执行大量任务会对 `cpu` 造成压力，进行流操作时会导致所有任务进度缓慢。

```js
class TaskParallelLimiter {
  taskList = []; // 待办事件列表
  activeThreadAmount = 0;
  maxThreadAmount = 5;
  host = null;

  constructor(host = this, limit = 5) {
    this.host = host;
    this.maxThreadAmount = limit;
  }

  // 添加事件
  push(fnName, ...args) {
    let task = fnName.bind(this.host, ...args);
    let _t = this;
    function packingTask() {
      _t.activeThreadAmount++;
      return task().finally(() => {
        _t.activeThreadAmount--;
        nextTask();
      });
    }
    function nextTask() {
      if (_t.activeThreadAmount < _t.maxThreadAmount) {
        let next = _t.taskList.shift();
        if (next) {
          next().finally(() => {
            nextTask();
          });
        }
      }
    }
    if (this.activeThreadAmount < this.maxThreadAmount) {
      packingTask();
    } else {
      this.taskList.push(packingTask);
    }
  }
}
```

`TaskParallelLimiter(host, limit)` 构造函数接收两个参数：

- host：添加任务时会将方法的 `this` 指向 `host`。
- limit：最大并发数。

被 `taskLimiter.push()` 推入任务队列的方法必须返回一个 `Promise` 对象。

```js
let taskLimiter = new TaskParallelLimiter(this, 3);

function task() {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(1);
      resolve();
    }, 1000);
  });
}

let len = 10;
while (len-- > 0) {
  taskLimiter.push(task);
}
```
