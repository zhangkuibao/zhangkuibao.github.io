---
date: 2021-09-09 14:22:30
title: 算法及思路
tags:
  - myGit
  - learning-Notes
  - document
  - technology
  - 常用代码
  - JS
---

## 找出给定数组中的最大差值

```javascript
function getMaxDiff(arr = []) {
  // Math.Max() 方法可接受多个参数进行比较
  // apply() 方法可将参数依次传入对应函数，call() 是传入参数数组， bind是生成一个转换了作用域的新函数
  // return Math.max.apply(null,arr) - Math.min.apply(null,arr);
  return Math.max(...arr) - Math.min(...arr); // es6语法
}
```

## 写一个方法，使得 sum(x)(y)和 sum(x,y)返回的结果相同

### 思路

对象转化为字符串会隐式调用 toString 方法

对象转化为数字会隐式调用 valueOf 方法

function 是一种特殊的对象类型，重写了 Object 的 toString 方法，默认会返回其函数体

### 代码实现

```js
// 写一个累加函数
function sum(x) {
  if (arguments[1]) {
    return [...arguments].reduce((x, y) => {
      return x + y;
    });
  } else {
    function add(b) {
      x += b;
      return add;
    }
    // toString方法在函数需要被转换为字符串时隐式调用，返回该函数的函数体（如直接在控制台中输入sum，			   打印出的就是隐式调用toString方法的结果）
    add.toString = function() {
      return x;
    };
    // 如果接下来还有函数调用，返回的add函数就会被调用，执行累加操作
    // 后面没有函数调用时，即没有括号时，返回的是add，这时就会隐式调用toString方法
    return add;
  }
}
sum(12)(23);
// 最终打印在控制台（chrome）上的内容是 f 35, 用typeof检测后结果是'function'
```

## 让（a == 1 && a == 2 && a ==3） == true

### 思路

ES6 的 `Object.defineProperty` 方法，利用一个中间值，在每次请求 a 的时候返回该值的累加

### 代码实现

```js
let val = 0;
Object.defineProperty(window, "a", {
  get: function() {
    return ++val;
  },
});
console.log(a == 1 && a == 2 && a == 3); // true
console.log(a === 1 && a === 2 && a === 3); // true, 原始值之间的比较
console.log(a); // 4, 每次操作都会调用get方法
```

#### 对象转换为数字时隐式调用 `toString` 方法

```js
let a = {
  value: 0,
  valueOf() {
    return ++this.value;
  },
};
console.log(a == 1 && a == 2 && a == 3); // true
console.log(a === 1 && a === 2 && a === 3); // false
console.log(a); // {value:3, valueOf: fn}, 本质还是对象
```

#### 数组与数字判断时会转字符串再转数字

```js
var a = [1, 2, 3];
a.toString = a.shift;
console.log(a == 1 && a == 2 && a == 3); // true
console.log(a); // [toString:fn]
```

## 找到数组中相加之和等于目标值的元素

输入一个数组及一个目标值，输出数组中相加之和等于目标值的两数的下标，多个匹配则用数组表示，用过的数字不能再用

如：输入([1,2,3,4,5,4,3,2,1],4) 输出：[[0,2],[1,7],[6,8]]

### 思路

遍历 nums，每个值相加

如果等于 target，将这两个数的下标保存到对象中

每次循环前判断该下标有没有使用过

```js
function twoSum(nums, target) {
  let { num = [] } = { num: nums };
  // 容错处理
  let arr = [];
  let noObj = {};
  for (let i = 0; i < num.length; i++) {
    if (noObj[i]) {
      // 如果该下标已使用则跳出本次循环
      continue;
    }
    for (let j = i + 1; j < num.length; j++) {
      if (noObj[j]) {
        continue;
      }
      if (num[i] + num[j] == target) {
        // 如果有多个匹配项添加到数组中
        arr.push([i, j]);
        // 将已使用下标保存到对象
        noObj[i] = i;
        noObj[j] = j;
        break;
      }
    }
  }
  return arr;
}
```

## 找到字符串中的最长不重复子串的长度

### 思路

#### 移动窗口

用对象记录字符及其下标，有相同的则移动左侧游标，保持三个数，left，right，num

[a,b,c],b,b 没有相同的,用对象记录每个字符出现的位置 --- {a:0,b:1,c:3} --- 更新计数器 mex(num,(right - left))

[a,b,c,b],b --- a,b,[c,b],b 出现了相同的字符时将左侧游标右移至已出现字符下标+1 的位置

#### 数组保存

将所有可能添加到字符串中的字符都保存在数组中，判断当前位是值（10,400,9000 等），将对应字符加入

### 代码实现

```js
function lengthOfLongestSubstring(s) {
  let num = 0,
    obj = {},
    left = 0;
  if (!s) return 0;
  if (s.length === 1) return 1;
  for (let right = 0; right < s.length; right++) {
    // 有重复的或索引为0
    if (obj[s[right]] || obj[s[right]] == 0) {
      // 有重复的但是是在左游标之前
      if (obj[s[right]] < left) {
        obj[s[right]] = right;
        console.log("true");
      } else {
        left = obj[s[right]] + 1;
        obj[s[right]] = right;
        console.log("false");
      }
    } else {
      // 无重复添加对应值
      obj[s[right]] = right;
      console.log(left, right, obj, num);
    }
    num = Math.max(num, right - left + 1);
  }
  return num;
}
```

## 罗马数字转换为整数

罗马数字转换为整数,1 -- 1000

罗马数字计数从左往右依次相加

累加器 num，计数并返回,对象 obj 保存字母对应的数值

### 思路

判断当前位是否为： I | X | C , 有三种情况： 一.（I 为 V | X ) ； 二.(X 后可为 L | C)； 三.(C 后可为 D | M)

### 代码实现

```js
var romanToInt = function(s) {
  let obj = {
      I: 1,
      V: 5,
      X: 10,
      L: 50,
      C: 100,
      D: 500,
      M: 1000,
    },
    num = 0;
  for (let i = 0; i < s.length; i++) {
    if (s[i] == "I") {
      if (s[i + 1] == "V" || s[i + 1] == "X") {
        num += obj[s[i + 1]] - obj[s[i]];
        i += 1;
        continue;
      } else {
        num += obj[s[i]];
      }
    } else if (s[i] == "X") {
      if (s[i + 1] == "L" || s[i + 1] == "C") {
        num += obj[s[i + 1]] - obj[s[i]];
        i += 1;
        continue;
      } else {
        num += obj[s[i]];
      }
    } else if (s[i] == "C") {
      if (s[i + 1] == "D" || s[i + 1] == "M") {
        num += obj[s[i + 1]] - obj[s[i]];
        i += 1;
        continue;
      } else {
        num += obj[s[i]];
      }
    } else {
      num += obj[s[i]];
    }
  }
  return num;
};
```

## 查找字符串中的第一串有效数字

myAtoi('+123#\$24') ---> +123

```js
function myAtoi(str) {
  let reStr = "",
    key = true,
    spKey = true;
  for (let i = 0; i < str.length; i++) {
    // 丢弃无用字符
    if (str[i] == " ") {
      if (spKey) {
        console.log("空格");
        continue;
      } else {
        break;
      }
    } else if (str[i] == "-" || str[i] == "+") {
      if (key) {
        console.log("加符号", str[i], reStr);
        reStr += str[i];
        key = false;
        spKey = false;
      } else {
        console.log("被符号阻断");
        break;
      }
    } else if (str[i].charCodeAt() <= 58 && str[i].charCodeAt() >= 47) {
      reStr += str[i];
      console.log("为数字", str[i], reStr);
      spKey = false;
      key = false;
    } else {
      console.log("无效字符");
      break;
    }
  }
  if (+reStr > Math.pow(2, 31) - 1) {
    return 2147483647;
  } else if (+reStr < -(Math.pow(2, 31) - 1)) {
    return -2147483648;
  } else if (!+reStr) {
    return 0;
  } else {
    console.log("无事发生");
    return reStr;
  }
}
```

## Z 字形变换

Z 字形变换

输入：'12345678'，3

输出：15246837

1 5

2 4 6 8

3 7

### 思路

    控制方向记录每行的内容，当行数等于参数或等于1（不是第一次）时变换方向

    三个变量：

    obj保存每行的内容 {行数：内容}

    turn为方向

    row为行数

### 代码实现

```js
var convert = function(s, numRows) {
  let obj = {},
    turn = 1, // 1为向下
    row = "1",
    reObj = "";
  if (numRows == 1) return s;
  for (let i = 0; i < s.length; i++) {
    if (!obj[row]) {
      obj[row] = s[i];
    } else {
      obj[row] += s[i];
    }
    if (row == numRows || (row == 1 && typeof row != "string")) {
      turn *= -1;
    }
    row *= 1;
    row += turn;
  }
  for (const prop in obj) {
    reObj += obj[prop];
  }
  return obj;
};
```
