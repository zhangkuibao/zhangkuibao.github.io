---
date: 2021-09-08 18:16:04
title: 相等性判断
tags:
  - myGit
  - learning-Notes
  - document
  - 技术
  - JavaScript
  - JS特性
---

## 判断方法

### ===

1. 类型不同时为 false
2. NaN 与任何值都不全等，包括它自己，即一方为 NaN 时为 false
3. 对于非数值而言该值只与自身全等
4. 对于数值：浮点数 0 不分正负，即 `+0 === -0`成立

#### 全等算法

    If Type(x) is different from Type(y), return false.
    If Type(x) is Undefined, return true.
    If Type(x) is Null, return true.
    If Type(x) is Number, then
        If x is NaN, return false.
        If y is NaN, return false.
        If x is the same Number value as y, return true.
        If x is +0 and y is −0, return true.
        If x is −0 and y is +0, return true.
        Return false.
    If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return false.
    If Type(x) is Boolean, return true if x and y are both true or both false; otherwise, return false.
    Return true if x and y refer to the same object. Otherwise, return false.

#### 特殊值比较

```js
undefined === undefined; // true
null === null; // true
undefined === null; // false
(NaN ===
  NaN + // false
    0) ===
  -0; // true
```

### ==

1. 比较前将两个比较的值转换为同一类型，转换后的比较方式等同于 ===
2. 相等操作符满足交换律（左右双方调换不会影响最终结果）

相等操作符对于不同类型的值，进行的比较如下图所示(行为比较值 A，列为比较值 B)：

|       |               | B             |          |                       |                               |                               |                               |
| ----- | ------------- | ------------- | -------- | --------------------- | ----------------------------- | ----------------------------- | ----------------------------- |
|       |               | **Undefined** | **Null** | **Number**            | **String**                    | **Boolean**                   | **Object**                    |
| **A** | **Undefined** | `true`        | `true`   | `false`               | `false`                       | `false`                       | `IsFalsy(B)`                  |
|       | **Null**      | `true`        | `true`   | `false`               | `false`                       | `false`                       | `IsFalsy(B)`                  |
|       | **Number**    | `false`       | `false`  | `A === B`             | `A === ToNumber(B)`           | `A=== ToNumber(B)`            | `A== ToPrimitive(B)`          |
|       | **String**    | `false`       | `false`  | `ToNumber(A) === B`   | `A === B`                     | `ToNumber(A) === ToNumber(B)` | `ToPrimitive(B) == A`         |
|       | **Boolean**   | `false`       | `false`  | `ToNumber(A) === B`   | `ToNumber(A) === ToNumber(B)` | `A === B`                     | ToNumber(A) == ToPrimitive(B) |
|       | **Object**    | false         | false    | `ToPrimitive(A) == B` | `ToPrimitive(A) == B`         | ToPrimitive(A) == ToNumber(B) | `A === B`                     |

`ToNumber(A)` 尝试在比较前将参数 A 转换为数字

`ToPrimitive(A)`通过尝试调用 A 的`A.toString()` 和 `A.valueOf()` 方法，将参数 A 转换为原始值（Primitive）

```js
undefined == undefined; // true
null == null; // true
undefined == null; // true
NaN === NaN; // false
```

### Object.is()

行为与 `===` 相同，但是对于 NaN 和-0 和+0 进行特殊处理

```js
Object.is(NaN, NaN); // true
Object.is(+0, -0); // false
Object.is(NaN, NaN); // true
```

## 三种比较方式对不同值的处理

|         x         |         y         |    ==     |    ===    | Object.is |
| :---------------: | :---------------: | :-------: | :-------: | :-------: |
|     undefined     |     undefined     |   true    |   true    |   true    |
|       null        |       null        |   true    |   true    |   true    |
|       true        |       true        |   true    |   true    |   true    |
|       false       |       false       |   true    |   true    |   true    |
|       "foo"       |       "foo"       |   true    |   true    |   true    |
|         0         |         0         |   true    |   true    |   true    |
|        +0         |        -0         |   true    |   true    | **false** |
|         0         |       false       |   true    | **false** | **false** |
|        ""         |       false       |   true    | **false** | **false** |
|        ""         |         0         |   true    | **false** | **false** |
|        "0"        |         0         |   true    | **false** | **false** |
|       "17"        |        17         |   true    | **false** | **false** |
|       [1,2]       |       "1,2"       |   true    | **false** | **false** |
| new String("foo") |       "foo"       |   true    | **false** | **false** |
|       null        |     undefined     |   true    | **false** | **false** |
|       null        |       false       | **false** | **false** | **false** |
|     undefined     |       false       | **false** | **false** | **false** |
|  { foo: "bar" }   |  { foo: "bar" }   | **false** | **false** | **false** |
| new String("foo") | new String("foo") | **false** | **false** | **false** |
|         0         |       null        | **false** | **false** | **false** |
|         0         |        NaN        | **false** | **false** | **false** |
|       "foo"       |        NaN        | **false** | **false** | **false** |
|        NaN        |        NaN        | **false** | **false** |   true    |

## 规范中的相等、严格相等以及同值相等

在 ES5 中， [`==`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators) 相等在 [Section 11.9.3, The Abstract Equality Algorithm](https://ecma-international.org/ecma-262/5.1/#sec-11.9.3)； [`===`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators) 相等在 [11.9.6, The Strict Equality Algorithm](https://ecma-international.org/ecma-262/5.1/#sec-11.9.6)。（请参考这两个链接，他们很简洁易懂。提示：请先阅读严格相等的算法）ES5 也提供了 same-value 相等， [Section 9.12, The SameValue Algorithm](https://ecma-international.org/ecma-262/5.1/#sec-9.12) ，用在 JS 引擎内部。除了 11.9.6.4 和 9.12.4 在处理数字上的不同外，它基本和严格相等算法相同。ES6 简单地通过 [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) 暴露了这个算法。

## 其他

1. 全等操作符的结果更容易预测，并且因为没有隐式转换，全等比较的操作会更快。
2. === 是 == 的子集
