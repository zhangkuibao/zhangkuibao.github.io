---
date: 2021-09-07 14:15:43
title: 守卫
tags:
  - myGit
  - learning-Notes
  - document
  - 技术
  - Nest
---

守卫是一个使用 @Injectable() 装饰器的类。 守卫应该实现 CanActivate 接口。

守卫在**每个中间件**之后执行，但在任何拦截器或管道之前执行。

在守卫中可以获取 request 请求对象。

## 定义守卫

守卫可以直接返回 false 也可以抛出异常。

- auth.guard.ts

```js
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  HttpException,
} from "@nestjs/common";
import { Observable } from "rxjs";

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    context: ExecutionContext
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();
    throw new HttpException("sdf", 400);
    return false;
  }
}
```

## 绑定守卫

使用 @UseGuards() 装饰器绑定守卫。

根据绑定位置不同分为方法范围、控制器范围和全局范围。

- app.controller.ts

```js
import { Controller, All, UseGuards } from "@nestjs/common";
import { AuthGuard } from "./guard/auth.guard";
@Controller()
export class AppController {
  @All()
  @UseGuards(AuthGuard)
  findAll() {
    return "htllo world";
  }
}
```

### 绑定全局守卫

- main.ts

```js
import { AuthGuard } from "./guard/auth.guard";
const app = await NestFactory.create(AppModule);
app.useGlobalGuards(new AuthGuard());
```
