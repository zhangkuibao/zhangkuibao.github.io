<author-info date="1638173528711"></author-info>

# 处理文件

`gulp` 处理文件的过程是：`src(glob)` 获取文件流，`pipe(plugin)` 修改文件，`pipe(dest(output))` 输出文件。

`gulp` 暴露了 `src()` 和 `dest()` 方法用于处理计算机上存放的文件。

`src()` 接受 `glob`（普通字符或通配符组成的字符串，用于匹配文件路径）组字符串或由多个 `glob` 字符串组成的数组作为参数，并从文件系统中读取文件然后生成一个 Node 流（stream）。

流（stream）所提供的主要的 API 是 `.pipe()` 方法，用于连接转换流（Transform streams）或可写流（Writable streams）。

`dest()` 接受一个输出目录作为参数，并且它还会产生一个 Node 流（stream），通常作为终止流（terminator stream）。

```js
const { src, dest } = require("gulp");
const babel = require("gulp-babel");

exports.default = function () {
  return src("src/*.js").pipe(babel()).pipe(dest("output/"));
};
```

## 向流中添加文件

`src()` 也可以放在管道（pipeline）的中间，新加入的文件只可在后续的转换中修改。

如果 `glob` 匹配的文件与之前的有重复，仍然会再次添加文件。

```js
const { src, dest } = require("gulp");
const babel = require("gulp-babel");
const uglify = require("gulp-uglify");

exports.default = function () {
  return src("src/*.js")
    .pipe(babel())
    .pipe(src("vendor/*.js"))
    .pipe(uglify())
    .pipe(dest("output/"));
};
```

## 分阶段输出

可以使用多个 `dest()` 进行多次输出。

此功能可用于在同一个管道（pipeline）中创建未压缩（unminified）和已压缩（minified）的文件。

```js
const { src, dest } = require("gulp");
const babel = require("gulp-babel");
const uglify = require("gulp-uglify");
const rename = require("gulp-rename");

exports.default = function () {
  return src("src/*.js")
    .pipe(babel())
    .pipe(src("vendor/*.js"))
    .pipe(dest("output/"))
    .pipe(uglify())
    .pipe(rename({ extname: ".min.js" }))
    .pipe(dest("output/"));
};
```

## 插件

Gulp 插件实质上是 Node 转换流（Transform Streams），通常是放在 `.pipe()` 中。

可以用插件更改经过流（stream）的每个文件的文件名、元数据或文件内容。

每个插件应当只完成必要的工作。

### 条件插件

插件的操作不应该针对特定文件类型，可以使用像 gulp-if 之类的插件来判断是否使用插件。

```js
const { src, dest } = require("gulp");
const gulpif = require("gulp-if");
const uglify = require("gulp-uglify");

function isJavaScript(file) {
  // 判断文件的扩展名是否是 '.js'
  return file.extname === ".js";
}

exports.default = function () {
  // 在同一个管道（pipeline）上处理 JavaScript 和 CSS 文件
  return (
    src(["src/*.js", "src/*.css"])
      // 只对 JavaScript 文件应用 gulp-uglify 插件
      .pipe(gulpif(isJavaScript, uglify()))
      .pipe(dest("output/"))
  );
};
```

## API

### src(glob)

`src()` 接受 `glob`组字符串或由多个 `glob` 字符串组成的数组作为参数。

`glob` 或 `glob` 数组必须至少匹配到一个匹配项，否则 `src()` 将报错。

### glob

glob 是由普通字符或通配符组成的字符串，用于匹配文件路径。

可以利用一个或多个 glob 在文件系统中定位文件。

当使用 glob 数组时，将按照每个 glob 在数组中的位置依次执行匹配。

#### 分隔符

glob 中用 `/` 表示分隔符。用 `\\` 表示转义符。

避免使用 Node 的 path 类方法来创建 glob，例如 path.join。

如下， `*` 被转义了，因此，`*` 将被作为一个普通字符使用，而不再是通配符了。

```js
"glob_with_uncommon_\\*_character.js";
```

#### 特殊字符：`*`（一个星号）

在一个字符串片段中匹配任意数量的字符，包括零个匹配。

对于匹配单级目录下的文件很有用。

下面这个 glob 能够匹配类似 index.js 的文件，但是不能匹配类似 scripts/index.js 或 scripts/nested/index.js 的文件。

```js
"*.js";
```

#### 特殊字符： `**` (两个星号)

在多个字符串片段中匹配任意数量的字符，包括零个匹配。

对于匹配嵌套目录下的文件很有用。

下面这个 glob 可以匹配 `scripts/` 目录下的所有 `.js` 后缀文件。它将匹配类似 `scripts/index.js`、`scripts/nested/index.js` 和 `scripts/nested/twice/index.js` 的文件。

```js
"scripts/**/*.js";
```

#### 特殊字符： ! (取反)

由于 glob 匹配时是按照每个 glob 在数组中的位置依次进行匹配操作的，所以 glob 数组中的取反（negative）glob 之前必须有一个非取反（non-negative）的 glob。

第一个 glob 匹配到一组匹配项，然后后面的取反 glob 删除这些匹配项中的一部分。

如果取反 glob 只是由普通字符组成的字符串，则执行效率是最高的。

下面的 glob 组合将匹配当前目录下所有的 `json` 文件和文件名不为 `gulpfile` 的所有 `js` 文件。

```js
["./*.json", "./*.js", "!gulpfile*"];
```

取反（negative） glob 可以作为对带有两个星号的 glob 的限制手段。

```js
["**/*.js", "!node_modules/"];
```

#### 匹配重叠

一个文件被多个 glob 匹配时改文件就被认为是匹配重叠了。

如果在同一个 `src()` 中使用了会产生匹配重叠的 glob，gulp 将尽力去除重叠部分，但是在多个 `src()` 调用时产生的匹配重叠是不会被去重的。

## 模式

src() 可以工作在三种模式下：**缓冲（buffering）**、**流动（streaming）**和**空（empty）**模式。

- 缓冲（Buffering）模式是默认模式，将文件内容加载到内存中。

  插件通常运行在缓冲（buffering）模式下，并且许多插件不支持流动（streaming）模式。

- 流动（Streaming）模式的存在主要用于**操作无法放入内存中的大文件**，例如巨幅图像或电影。

  文件内容从文件系统中**以小块的方式流式传输，而不是一次性全部加载**。

  如果需要流动（streaming）模式，请查找支持此模式的插件或自己编写。

- 空（Empty）模式不包含任何内容，仅在处理文件元数据时有用。


## 参考

[处理文件](https://www.gulpjs.com.cn/docs/getting-started/working-with-files/)
