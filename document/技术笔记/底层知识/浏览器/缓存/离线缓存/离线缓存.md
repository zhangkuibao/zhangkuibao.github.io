<author-info date="1631169123554"></author-info>


# 离线缓存

## 场景

可以在离线情况下访问的网站大概可以分为两类，一类是“可以离线使用”的网站，他们的主要逻辑在客户端实现，服务端只提供一些数据；而另一类则是“可以离线查看”的网站，这些网站的主要逻辑在服务端实现。

## 方案

### ServiceWorker

一个特殊的 worker 线程，相当于服务器和浏览器之间的中间件，注册了 Service Worker 的网站，Service Worker 可以拦截这个网站的请求，根据代码来判断要执行的缓存策略和使用缓存的策略。

### ApplicationCache(manifest)

即 Application cache，ServiceWorker 之前的缓存解决方案，目前已废弃。

即使在线，文件也从 ApplicationCache 中加载，在 ServiceWorker 中这是可以自行决定的。

ApplicationCache 只在 Manifest 文件改变的时候更新。如果在你的 manifest 中有 50 个 html 页面，每次你在线的情况下访问他们的时候，浏览器会创建 50 个网络请求来确认他们是不是需要更新。manifest 文件比较是以二进制方式进行的。

更新 manifaset 文件路径，用户再访问页面时，他们会获取 ApplicationCache 的版本，如果已经更改了 manifest 文件地址的话，很不幸的，用户缓存的版本依然指向旧的 manifest 文件，它就永远不会更新了，永远。

ApplicationCache 的规则更像是一个洋葱，它有很多很多层，随着你慢慢剥开它，眼泪也会慢慢流下来。

## 参考

[ApplicationCache 是个坑](http://zoomzhao.github.io/2012/11/11/application-cache-is-a-douchebag/)
