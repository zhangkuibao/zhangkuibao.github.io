<author-info date="1631151376405"></author-info>

# 类

## 摘要

1. 使用 `extends` 关键字实现类继承。
2. `private` 修饰的成员只能在声明它的类中访问，`protected` 修饰的成员可以在声明它的类的派生类中访问。
3. 将构造函数用 `protected` 修饰意味着这个类不能在外部被实例化，但是能被继承。
4. 只带有 `get` 不带有 `set` 的存取器自动被推断为 `readonly`。
5. 实例化一个类时创建出的实例的类型就是该类。
6. 一个类只能继承自一个父类，但是可以同时实现多个接口。
7. 用 `implements` 关键字让一个类实现其他类从而实现混入。

## 修饰符

在 `TypeScript` 里，成员都默认为 `public`。

### private 私有

当成员被标记成 `private` 时，它只能在**声明它的类**中访问，不能在派生类和其他类中访问。

```js
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // 错误: 'name' 是私有的.
```

### protected 受保护

`protected` 修饰符与 `private` 修饰符的行为很相似，但有一点不同， `protected` 成员在派生类中仍然可以访问。

```js
class Animal {
  private name: string;
  protected age: string;
  constructor(theName: string) { this.name = theName; }
}
class Employee extends Animal {
  getProperty() {
    this.name;  // name无法访问
    this.age    // age可以访问
  }
}
```

#### 用 protected 修饰 constructor

```js
class Animal {
  protected constructor(theName: string) { this.name = theName; }
}
class Employee extends Animal {
  constructor() {
    super('employee');
  }
}

new Animal();   // error，Animal的构造函数是受保护的
new Employee(); // success
```

### readonly 只读

只读属性必须在声明时或构造函数里被初始化。

## 存取器 getter/setter

只带有 `get` 不带有 `set` 的存取器自动被推断为 `readonly`

## 静态属性

用 `static` 在类中定义静态成员，访问静态成员需要在成员名之前加上类名。

## 抽象类

用 `abstract` 定义抽象类，抽象类只能被继承不能实例化。

可以用 `abstract` 关键字在抽象类中定义抽象成员，抽象成员必须在派生类中实现。

抽象成员可以在 `abstract` 之前使用修饰符，不能使用 `private` 修饰符

```js
abstract class Animal {
    abstract makeSound(): void;
    protected abstract name: string;
    move(): void {
        console.log('roaming the earch...');
    }
}

class AllAnimal extends Animal {
  makeSound() {}
  name;
}
```

## mixins 混入

用 `implements` 关键字让一个类实现其他类从而实现混入。

把类当成了接口，仅被实现类的类型而非其实现。

```js
class Disposable {
  isDisposed: boolean;
}

// Activatable Mixin
class Activatable {
  isActive: boolean = true;
}

class SmartObject implements Disposable, Activatable {
  isActive;
  isDisposed;
}
```
