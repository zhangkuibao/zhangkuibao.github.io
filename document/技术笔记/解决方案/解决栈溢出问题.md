<author-info date="1645698172570"></author-info>

# 解决栈溢出问题

## 关于栈溢出错误

函数调用会在内存形成一个 `调用记录`，又称 `调用帧（call frame）`，保存调用位置和内部变量等信息，所有的调用帧存放在调用堆栈中。

栈溢出错误常见于递归操作用，函数不断地重复调用自身导致调用堆栈不断堆叠，在超出浏览器限制的调用堆栈大小时抛出栈溢出错误 `Uncaught RangeError: Maximum call stack size exceeded`

## 解决问题

以阶乘函数为例：

```js
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1); // 返回了一个函数调用与变量的表达式
}
```

### 尾递归

此方案大部分浏览器不支持。

尾递归的优化方式依赖于 `ES` 的 `尾调用优化` 方案。

尾调用就是指某个函数的最后一步是调用另一个函数，由于这是当前函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

尾递归方式改写：

```js
function factorial(n, total = 1) {
  if (n === 1) return total; // total为计算值也是最后的返回值
  return factorial(n - 1, n * total); // 返回了一个函数调用
}
```

### 改为迭代

尾递归的支持性并不好，想在正常环境下使用尾递归优化就需要自己实现尾递归。

原理：使用 `循环` 替换 `递归`。
1. 改写递归函数，让递归函数每次返回一个新函数。
2. 添加一个新的 `蹦床函数`，用来执行递归函数返回的函数。

这里改写后就变成了每次执行函数就返回一个新函数，然后执行该函数，而不是在函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。

迭代方式改写：

```js
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}

function factorial(n, total = 1) {
  if (n === 1) return total; // total为计算值也是最后的返回值
  return factorial.bind(null, n - 1, n * total); // 返回了一个函数调用
}

trampoline(factorial(20000));
```

## 参考

[尾递归优化的实现](https://es6.ruanyifeng.com/?search=%E5%B0%BE%E8%B0%83%E7%94%A8&x=0&y=0#docs/function#%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0)