<author-info date="1641618957304"></author-info>

# 高性能JavaScript编程

## 加载和运行

`js` 会阻塞浏览器执行其他任务，当 `js` 运行时浏览器不会处理其他事情。

当浏览器遇到一个 `<script>` 标签时，会停下来运行此 `js`，然后继续解析页面；如果 `js` 是用 `src` 引入的，浏览器必须先下载外部文件的代码，然后解析并运行此代码，这个过程中页面解析和用户交互是被完全阻塞的。

### 摘要

1. 减少请求 `JS` 文件数量，可通过一个 `HTTP` 请求多个 `JS` 文件。
2. 避免前置加载 `<script>` 标签，因为它会阻塞浏览器进程。

### `<script>` 标签的位置

浏览器遇到 `<body>` 标签之前不会渲染页面的任何部分，因此在 `head` 中引入 `<script>` 标签会导致可察觉的延迟。

### 联合加载js

每个 `HTTP` 请求都会产生额外的性能负担，下载一个 `100KB` 的文件比下载四个 `25KB` 的文件要快。

可以把多个 `JS` 文件通过一个 `HTTP` 请求返回以减少 `HTTP` 请求次数。

### 非阻塞脚本

保持 `JS` 文件短小，并限制 `HTTP` 请求的数量，因为加载大文件虽然只发送一个 `HTTP` 请求但是在资源返回之前浏览器无法进行其他工作。

从技术角度讲，要在页面加载完之后再加载 `JS` 需要在 `window.onload` 事件触发后开始下载代码，有几种方法实现可以实现：

1. defer：`<script type="text/javascript" src="file1.js" defer></script>`。

  一个带有 `defer` 属性的 `<script>` 标签在被解析时启动下载，但直到 `DOM` 加载完成后才执行。此时 `JS` 文件与其他资源一同下载。

2. 动态节点加载 `JS` 文件。

  ```js 
    let script = document.createElement("script");
    script.src = "file.js";
    document.body.appendChild(script);
  ```

  上面的代码可以添加到页面任何地方而不用担心会阻塞页面。

  当文件使用动态脚本节点下载时，返回的代码通常立即执行。

3. 脚本注入。

  先请求 `JS` 文件，然后将得到的内容添加到一个新的 `<script>` 标签中，再把标签添加到页面，这样就能创建一个带有内联代码的 `<script>` 元素。

  这种方法的好处是可以控制 `JS` 代码的执行时机。



## 数据访问

### 摘要

1. 在函数中尽量使用局部变量，因为在函数执行上下文中会沿着作用域链向外查找变量。


### 函数执行

函数运行时会创建执行上下文，它定义了一个函数运行时的环境。对函数的每次运行而言，每个执行上下文都是唯一的，所以多次调用同一个函数会导致多次创建执行上下文。当函数执行完毕，执行上下文就会被销毁。
