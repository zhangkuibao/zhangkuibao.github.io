## 默认路径

webpack 可以不需要任何配置文件，此时 webpack 会假定项目的入口起点为 src/index.js，然后会在 dist/main.js 输出结果，并且在生产环境开启压缩和优化。

在项目根目录中创建一个 webpack.config.js，启动 webpack 时会自动使用它。

## 使用不同的配置文件

**package.json**
```js
"scripts": {
  "build": "webpack --config prod.config.js"
}
```

## 可配置项

**webpack.config.js**
```ts
const path = require('path');

type WebpackConfig = {
    mode: "production" | "development" | "none"    // 运行模式
    entry: string | string[] | EntryObject         // 入口
    output: OutputObject                           // 输出
    module: ModuleObject                           // 决定如何处理项目中不同类型的模块。
}

let config:WebpackConfig = {};
module.exports = config;
```

### entry

```ts
type EntryObject = {
    [chunkName: string]: string | string[] | EntrySubObject
}

type EntrySubObject = {
    dependOn: string | string[]    // 当前入口所依赖的模块。它们必须在该入口被加载前被加载。使用 dependOn 选项你可以与另一个入口 chunk 共享模块
    filename: string               // 指定要输出的文件名称。
    import: string | string[]      // 启动时需加载的模块。
    library: LibraryObject         // 同 output.library，在这里可以在设置多入口时为每个入口配置 library
    runtime: string                // 运行时 chunk 的名字。如果设置了，就会创建一个以这个名字命名的运行时 chunk，否则将使用现有的入口作为运行时。
    publicPath: string             // 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址。请查看 output.publicPath。
    layer: string
    chunkLoading: string
}
```

### output

```ts
type OutputObject = {
    filename: string | (pathData:any) => string     // 决定了每个输出 bundle 的名称。这些 bundle 将写入到 output.path 选项指定的目录下。可以使用 'js/[name]/bundle.js' 这样的文件夹结构
    chunkFilename: string | (pathData:any) => string          // 决定非初始（non-initial）chunk 文件的名称。默认使用 [id].js
    assetModuleFilename: string | (pathData:any) => string      // 决定 module 文件的名称，默认 [hash][ext][query]
    path: string                // output 目录对应的绝对路径。require('path').resolve(__dirname, 'dist/assets')
    publicPath: string | (x) => string          // 加载外部资源的路径
    scriptType: 'module' | 'text/javascript' | false      // 设置 <script> 标签的 type  值
    compareBeforeEmit: boolean              // 当要输出的文件已存在并且内容没有变更时，webpack 不会输出该文件。

    library: string | string[] | LibraryObject     // 将 entry 设定的入口输出为一个库（class）。
    libraryTarget: string
    auxiliaryComment: string       // 在 output.library 和 output.libraryTarget 一起使用时，此选项允许用户向导出容器(export wrapper)中插入注释。
    charset: string                // 为 <script> 标签添加 charset="utf-8" 标识
    chunkLoadTimeout: number       // chunk 请求到期之前的毫秒数，默认为 120000
    chunkLoading: 'jsonp' | 'import-scripts' | 'require' | 'async-node' | string        // 加载 chunk 的方法，（默认值有 'jsonp' (web)，'importScripts' (WebWorker)，'require' (sync node.js)，'async-node' (async node.js)，还有其他值可由插件添加)。
    chunkLoadingGlobal: string      // webpack 用于加载 chunk 的全局变量。
    chunkFormat: 'array-push' | 'commonjs' | string     // chunk 的格式，（默认包含 'array-push' (web/WebWorker)，'commonjs' (node.js)，还有其他情况可由插件添加）。
    crossOriginLoading: 'anonymous' | 'use-credentials'    // 启用 cross-origin 属性 加载 chunk。仅在 target 设置为 'web' 时生效，通过使用 JSONP 来添加脚本标签，实现按需加载模块。'anonymous' - 不带凭据(credential) 启用跨域加载；'use-credentials' - 携带凭据(credential) 启用跨域加载
    globalObject: 'self' | 'window' | 'this' | string        // 当输出为 library 时，尤其是当 libraryTarget 为 'umd'时，此选项将决定使用哪个全局对象来挂载 library。默认为 self
    uniqueName: string          // 在全局环境下为防止多个 webpack 运行时 冲突所使用的唯一名称。默认使用 output.library 名称或者上下文中的 package.json 的 包名称(package name)， 如果两者都不存在，值为 ''。
    hashDigest: string          // 在生成 hash 时使用的编码方式。对文件名使用 'base64'，可能会出现问题，因为 base64 字母表中具有 / 这个字符(character)。
    hashDigestLength: string    // hash 长度
    hashFunction: string | function     // 散列算法。支持 Node.JS crypto.createHash 的所有功能。
    pathinfo: boolean | 'verbose'           // 在 bundle 中引入「所包含模块信息」的相关注释。development 模式时默认为true，production 模式默认为 false，为 'verbose' 时，会显示更多信息
    sourceMapFilename: string       // 默认值 [file].map[query]，仅在 devtool 设置为 'source-map' 时有效
    strictModuleErrorHandling: boolean      // 加载模块时错误的处理方式 https://webpack.docschina.org/configuration/output/#outputstrictmoduleerrorhandling
    clean: boolean | { dry?: boolean, keep?: RegExp | string | ((filename: string) => boolean) }          // 生成文件前先清空输出目录 https://webpack.docschina.org/configuration/output/#outputclean

    // 现在或未来将被弃用的功能
    libraryExport           // 使用 output.library.export
    libraryTarget           // 使用 output.library.type
    strictModuleExceptionHandling   // 使用 output.strictModuleErrorHandling
}
```

### output.library/entry.library
省略 library.name 将导致入口起点返回的所有属性直接赋值给根对象

[不同type打包的差异](https://webpack.docschina.org/configuration/output/#exposeavariable)

可以通过 type 将功能打包成适配其他模块系统的模块。
```ts
type LibraryObject = {
    name: string | string[] | {amd?: string, commonjs?: string, root?: string | string[]}        // 库的名称，定义为对象时可配置打包为不同类型时的名称
    type: 'var' | 'module' | 'assign' | 'assign-properties' | 'this' | 'window' | 'self' | 'global' | 'commonjs' | 'commonjs2' | 'commonjs-module' | 'amd' | 'amd-require' | 'umd' | 'umd2' | 'jsonp' | 'system' | string        // 库的暴露方式，除内置可选项之外也可以通过插件添加。
    export: string | string[]       // 指定哪一个导出应该被暴露为一个库。默认为 undefined，将会导出整个（命名空间）对象。可通过传递数组指定某个具体的导出
}
```

### module

```ts
type ModuleObject = {
    generator: object               // 在一个地方配置所有生成器的选项。
    parser: ParserObject            // 在一个地方配置所有解析器的选项。
    rules: RuleObject[]             // 对匹配的文件应用 loader 或 parser
}

type ParserObject = {
    javascript: {
        noParse: RegExp | RegExp[] | (resource: string) => string | string[]    // 匹配的文件不会被解析。忽略的文件中 不应该含有 import, require, define 或任何其他导入机制。忽略大型的 library 可以提高构建性能。
        unsafeCache: boolean        // 缓存模块请求的解析，cache（webpack） 未启用时为 false，cache启用时如果此模块来自 node_modules 则为 true，否则为false

        commonjsMagicComments: boolean  // 为 CommonJS 启用 魔法注释。目前只支持 webpackIgnore 注释（5.17.0+）
        url: boolean | 'relative'    // 启用 new URL() 语法解析。设置为 relative（5.23+）时结果 URL 中不包含根 URL。适用于 SSR（服务端渲染）和 SSG（静态网站生成器）
    }
}

type RuleObject = {
    test: RegExp | RegExp[]         // 引入匹配的模块，如果你提供了一个 Rule.test 选项，就不能再提供 Rule.resource。
    use: string[] | UseObject[] | (info: {          // 引入 loader，存在多个 loader 时从右到左被应用。
        compiler            //  当前 webpack 的编译器（可以是 undefined 值）
        issuer              //  模块的路径，该元素正在导入一个被加载的模块(resource)
        realResource        //  总会是被加载模块的路径
        resource            //  被加载的模块路径，它常常与 realResource 相等，只有当资源名称被 request 字符串中的 !=! 覆盖时才不相等
    }) => (string[] | UseObject[])    

    resolve                 // 这些选项能设置模块如何被解析。所有被应用的 resolve 选项被更高层级的resolve配置合并。同 module.resolve

    parser: {           // 解析选项对象，所有应用的解析选项都将合并。https://webpack.docschina.org/configuration/module/#ruleparser
        dataUrlCondition: { maxSize: number } | (source, {filename, module}) => boolean     // 如果一个模块源码大小小于 maxSize，那么模块会被作为一个 Base64 编码的字符串注入到包中， 否则模块文件会被生成到输出的目标目录中。
    }
    generator: {
        dataUrl: {
            encoding: string | false,       // 模块源码编码方式，设置为 false 时会禁用编码。
            mimetype: string,               // 设置文件类型，默认根据模块资源后缀设置。
        } | ((content, { filename, module })=> string)
    }
    loader                   
           // Rule.loader 是 Rule.use: [ { loader } ] 的简写。类似的还有 Rule.options / Rule.query，均已废弃。
    loaders                         // Rule.use 的别名，已废弃。
    oneOf: RegExp | RegExp[]        // 规则数组，当规则匹配时，只使用第一个匹配规则。
    enforce: 'pre' | 'post'         // 指定 loader 类型，没有表示是普通 loader。
    exclude: RegExp | RegExp[]      // 排除符合条件的模块，如果你提供了 Rule.exclude 选项，就不能再提供 Rule.resource。
    include: RegExp | RegExp[]      // 引入符合条件的模块。如果你提供了 Rule.include 选项，就不能再提供 Rule.resource
    issuer: string                  // 这个选项可以用来将 loader 应用到一个特定模块或一组模块的依赖中。
    layer: string                   // 指定模块应放置在哪个 layer。
    mimetype: 'application/json' | 'text/javascript' | 'application/javascript' | 'application/node' | 'application/wasm' | string      // 使 rules 配置与 data 的 uri 进行匹配
    resource                        // 条件会匹配 resource。
}

type UseObject = {
    loader: string          // 要使用的 loader
    options: object         // 传递给 loader 的数据，可以理解为 loader 的选项。
}
```