<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ES6</title>
</head>

<body>
    <div>
        <script>
            var log = console.log;
        </script>
        <script class="1_字符串扩展">
            // 2_1 模板字符串
            function test2_1() {
                // 1.允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点
                // 2.ES6为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历
                for (const item of 'String') {
                    log(item)
                }

                // 3.模板字符串:多行,嵌套变量,要用到反引号需要转义,大括号内可进行运算(可引入对象属性,调用函数),
                //   模板字符串中的变量没有声明会报错, 大括号内实际就是执行js代码,模板字符串可嵌套
                let name = "String";
                let x = 5;
                let y = 10;
                log(`is js \` tamplate ${name} + ${x + y}`);

                // 3.1 标签模板 -- 用字符串传参执行函数, 应用: 过滤html字符串,防止用户恶意输入
                function tag(s, v1, v2) {
                    console.log(s);
                    console.log(v1);
                    console.log(v2);
                    return "OK";
                }
                tag `Hello ${ x + y } world ${ x * y}`;
                // 第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分,该数组有一个raw属性，保存的是转义后的原字符串。
                // 其他参数是模板字符串各个变量被替换后的值
                // tag接收到的参数为: [['hello ', ' world', ''], 15, 50]
            }

            // 2_2 字符串对象新增方法
            function test2_2() {
                var newNa = 'na'.repeat(3) // 将'na'重复3次,返回新字符串,参数为小数则取整,0到-1之间的小数当0处理,参数为字符串则转换为数字
                var newStr = 'x'.padStart(5, 'ab') // 如果字符串不够指定长度,在头部补齐,二参为补入的字符,如果新字符串长度过长则采取补全字符串
                var newStr = 'x'.padEnd(5) // 在尾部补入,省略二参默认用空格补齐
                var newStr = ' abc  '.trimStart() //  消除字符串头部空格,别名为trimLeft
                var newStr = ' abc  '.trimEnd() //  尾部,不改变原字符串,对空格,tab,换行等不可见空白符号都有效,别名为trimRight
                var newStr = 'ababababab'.matchAll(/a/) // 返回一个正则表达式在当前字符串的所有匹配
            }
        </script>
        <script class='2_正则的扩展'>

        </script>
        <script class='3_数值的扩展'>
            const Number = {
                T3() {
                    // 1.新的二进制和八进制数表示方法:0b/0B(二进制), 0o/0O(八进制), 将带有这两种前缀的值转换为十进制要使用Number方法: Number('0b111')
                    // 2.在Number对象上提供了Number.isFinite()和Number.isNaN()两个方法。注意:Number.isNaN != isNaN; 是两个不同的方法
                    // 0.它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，
                    // 0.而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 
                    Number.isInteger(); // 判断参数是否为整数,对非数值返回false,精度不好
                    Number.EPSILON; // 一个极小的常量,表示1与大于1的最小浮点数之间的差,可以用于标识js的最小精度,可用于设置误差范围
                    // 3.JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。
                    // 0.ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。
                    Number.MAX_SAFE_INTEGER // 9007199254740991
                    Number.MIN_SAFE_INTEGER // -9007199254740991
                    Number.isSafeInteger() // 用来判断一个整数是否落在这个范围之内。由于超出范围的数会以对应的临界值表示,所以精度不准

                    Math.trunc() // 用于去除一个数的小数部分,返回整数部分; 对于非数值会先用Number()方法转换为数值;对空值和无法截取整数的值返回NaN;
                    Math.sign(); // 判断一个数是正数,负数还是0,非数先转换为数值;为正返回1, 为负返回-1, 0返回0, -0返回-0, 其他值返回NaN
                    // 4.指数运算符: **, 右结合,先执行右侧的指数运算符
                    2 ** 3 // 8
                    2 ** 4 // 16
                    2 ** 3 ** 4 // ==> 2 ** (3 ** 4)
                    b **= 3 // ==> b = b ** 3
                }
            }
            
        </script>
        <script class='4_函数的扩展'>
            // 1.可以为函数的参数设置默认值
            function T1() {
                var T1_1 = function () {
                    // function foo(x, x, y = 4) {} // 不能有同名参数;
                    // 0.参数变量y是默认声明的,在函数体中,不能用let或const再次声明,否则会报错
                    let y = 'child' // error

                    // 0.参数默认值不是传值的,而是每次都重新计算默认表达式的值,所以该默认值是惰性求值的
                    let x = 99;

                    function foo(p = x + 1) {} // p的默认值不是固定的100,而是每次都计算赋值一次,即x++

                    // 0.与解构赋值结合
                    function fetch(url, {
                        body = '',
                        method = 'GET',
                        headers = {}
                    }) {
                        console.log(method, body, headers);
                    }
                    // 二参不传值会报错,
                    fetch('http://baidu.com', {
                        body: 'child',
                        headers: {
                            name: 'zkb'
                        }
                    }) // GET,child,{name:'zkb'}
                }
                var T1_2 = function () {
                    // 传参方式区别
                    function m1({
                        x = 0,
                        y = 0
                    } = {}) {
                        log(x, y)
                    }

                    function m2({
                        x,
                        y
                    } = {
                        x: 0,
                        y: 0
                    }) {
                        log(x, y)
                    }
                    // 函数没有参数的情况
                    m1() // [0, 0]
                    m2() // [0, 0]

                    // x 和 y 都有值的情况
                    m1({
                        x: 3,
                        y: 8
                    }) // [3, 8]
                    m2({
                        x: 3,
                        y: 8
                    }) // [3, 8]

                    // x 有值，y 无值的情况
                    m1({
                        x: 3
                    }) // [3, 0]
                    m2({
                        x: 3
                    }) // [3, undefined]

                    // x 和 y 都无值的情况
                    m1({}) // [0, 0];
                    m2({}) // [undefined, undefined]

                    m1({
                        z: 3
                    }) // [0, 0]
                    m2({
                        z: 3
                    }) // [undefined, undefined]
                }

                var T1_3 = function () {
                    // 参数默认值赋值不是定义时执行而是运行时执行,可将参数默认值设置为undefined表名这个参数是可以省略的
                    // 0.函数的length属性返回没有指定默认值的参数个数 -- 如果指定默认值的参数不是尾参数,length属性不会计入后面的参数,length属性不包括rest参数
                    function len(x, y, c = 2) {} // len.length = 2
                    function len(x = 2, y, c) {} // len.length = 0

                    // 0.一单设置了参数的默认值,函数进行声明初始化时,参数会形成单独的作用域,等到初始化结束,这个作用域就会消失,只在设置默认值时出现
                    var x = 1;

                    function f(x, y = x) {
                        console.log(y);
                    }
                    f(2); // 2, 参数y的默认值是变量x,调用函数f时,参数形成一个独立作用域,该域中默认值变量x指向第一个参数x,而不是全局变量x,所以输出2
                    function f(y = x) {
                        let x = 2;
                        console.log(y);
                    }
                    f() // 1, 参数默认值生成的作用域中没有定义x,函数体中定义的x要等到参数复制完毕后才执行,如果此时全局x不存在则报错
                    function f(x = x) {
                        console.log(x)
                    }
                    f() // 报错, 参数x = x形成一个单独作用域,实际执行的是let x = x; 形成暂时性死区,报错为x未定义
                    function bar(func = () => foo) {
                        let x = 2;
                        log(func());
                    }
                    f() // 1, 默认参数为函数时也遵循上述规则

                    // 应用:利用参数默认值,可指定某个参数不得省略
                    function throwM() {
                        throw new Error("do not miss")
                    }

                    function foo(x = thorwM()) {
                        return x
                    }
                    foo() // 如果不传参的话就报错
                }

                var T1_4 = function () {
                    // es6引入rest参数(扩展运算符), 形式为 ... ,用于获取函数的多余参数,rest参数只能是函数的最后一个参数,否则会报错,函数的length属性不包括rest参数
                    function add(...values) {
                        let sum = 0;
                        for (var val of values) {
                            sum += val
                        }
                        return sum;
                    }
                    add(2, 5, 3) // 10;

                    // 0.用rest代替auguments
                    function foo() {
                        let fo1 = Array.prototype.slice.call(arguments)
                            .sort(); // arguments对象不是数组,而是类数组,要使用数组方法得用slice方法转换为数组
                        let fo2 = (...numbers) => numbers.sort(); // rest参数是一个真正的数组,可以使用数组的方法
                    }

                }

                var T1_5 = function () {
                    // 函数内部可设置为严格模式
                    "use strict"

                    // ES2016规定只要函数参数设置了默认值,解构赋值或者扩展运算符(...),name函数内部再显式的设置严格模式会报错
                    // 有两种规避限制的方法：1.设置全局性的严格模式，2.把函数包在一个无参数的立即执行函数里
                    (function () {
                        "use strict";
                        return function (value = 42) {
                            return value
                        }
                    })()

                    // 函数的name属性,返回该函数的函数名;
                    var f = function () {};
                    f.name; // "f", 将匿名函数赋值给变量时,ES5中为空串,ES6会返回函数名
                }

                var T1_6 = function () {
                    // 箭头函数,要返回对象必须用{}扩起来
                    let foo = () => {
                        a: 1
                    };
                    foo() // undefined
                    // 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。
                    // 这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。

                    // 应用: 
                    // 0.简化回调函数
                    [1, 2, 3].sort((a, b) => a - b);

                    // 0.与rest结合
                    var numbers = (one, ...nums) => [one, nums];
                    numbers(1, 2, 3, 4); // [1,[2,3,4]]

                    // 0.与结构结合
                    var full = ({
                        first,
                        last
                    }) => first + " " + last;
                    full("hello", "world"); // hello world

                    "注意"
                    // 1.箭头函数没有自己的this,函数体内的this指向的是{定义时}所在的对象,而不是使用时所在的对象;该特性让箭头函数有利于封装回调函数
                    // 2.不可以当做构造函数,不能用new,否则报错;
                    // 3.不可以使用auguments对象,该对象在函数体内不存在,可用rest代替;
                    // 4.不可以使用yield命令,因为箭头函数不能用作Generator函数;
                    // 5.arguments、super、new.target这三个变量在箭头函数中不存在,指向外层函数的对应变量
                    // 6.箭头函数没有自己的this,所以无法用call,apply,bind改变this指向(使用这些方法时无效,内部的this指向外部的this)

                    // 0.举例:定时器 -- 定时器中的this指向window
                    function Timer() {
                        this.s1 = 0;
                        this.s2 = 0;
                        // 箭头函数
                        setInterval(() => this.s1++, 1000); // this指向new Timer()对象
                        // 普通函数
                        setInterval(function () {
                            this.s2++; // this指向window
                        }, 1000);
                    }
                    var timer = new Timer();

                    setTimeout(() => console.log('s1: ', timer.s1), 3100);
                    setTimeout(() => console.log('s2: ', timer.s2), 3100);
                    // 箭头函数定义时其this指向new Timer() 这个对象,这个对象里有变量s1,s2及两个定时器
                    // s1: 3; 修改是 new Timer().s1
                    // s2: 0; 修改的是window.s2 --- 当前的isNaN(window.s2) == true; (undefined + 1 == NaN)


                    // 0.举例:封装回调函数,下例中dom事件的回调函数被封装在一个对象中
                    var handler = {
                        id: '123456',
                        init: function () {
                            document.addEventListener('click',
                                event => this.doSomething(event.type), false
                                ); // this永远指向handler对象,不用箭头函数的话this会指向document,会报错
                        },
                        doSomething: function (type) {
                            console.log('Handling ' + type + ' for ' + this.id);
                        }
                    }

                    "不适用的场合"
                    // 由于箭头函数让this从动态变成静态,下列场合不适用

                    // 1.包含this的对象方法
                    let cat = {
                        health: 100,
                        dead: () => this.health-- // 调用cat.dead()时,this永远指向window(对象不构成单独的作用域),而不是指向cat;
                    }

                    // 2.需要动态this的时候
                    btn.onclick = function () {
                        this.classList.toggle('on'); // btn的监听函数是一个箭头函数,所以里面的this就是window
                    }

                    // 3.函数体很复杂或函数内部有大量读写操作,这时也不应该使用箭头函数,会降低代码可读性

                    "尾调用优化"
                    // 函数调用时生成调用记录,保存调用位置和内部变量等信息(调用帧)(作用域链?),尾调用是函数的最后一步操作,
                    // 在进行尾调用时可以不用保存外部的调用信息,节省内存
                    function addOne(a) {
                        var one = 1;

                        function inner(b) {
                            return b + one;
                        }
                        return inner(a); // inner函数用到了addOne函数的内部变量所以不会尾调用优化
                        return other(); // 如这样完全没用到该函数内变量的调用才会进行优化(意义?)
                    }

                    // 作用:尾递归,递归要保存很多个调用帧,很容易发生"栈溢出"错误,但由于尾调用只有一个调用帧,所以永远不会发生栈溢出
                    // 1.阶乘
                    function factorial(n) {
                        if (n === 1) return 1;
                        return n * factorial(n - 1);
                    }
                    factorial(5) // 120, 阶乘函数,复杂度O(n)

                    function factorial(n, total) {
                        if (n === 1) return total; // total为计算值也是最后的返回值
                        return factorial(n - 1, n * total);
                    }
                    factorial(5, 1) // 120, 改为尾调用,复杂度O(1)

                    // 2.斐波那契数列
                    function Fibonacci(n) {
                        if (n <= 1) {
                            return 1
                        };
                        return Fibonacci(n - 1) + Fibonacci(n - 2); // 常规写法,超时
                    }
                    Fibonacci(100) // 超时

                    function Fibonacci(n, ac1 = 1, ac2 = 1) {
                        if (n <= 1) {
                            return ac2
                        };
                        return Fibonacci(n - 1, ac2, ac1 + ac2); // 尾调用优化
                    }
                    Fibonacci(500) // 迅速给出结果

                    "非严格模式下模拟尾调用"

                    function sum(x, y) {
                        if (y > 0) {
                            return sum(x + 1, y - 1);
                        } else {
                            return x;
                        }
                    }
                    sum(1, 100000000); // 报错,超出调用栈的最大次数

                    // 1.蹦床函数,接收一个函数作为参数,只要f执行完毕后返回一个函数就继续执行,这样是返回一个函数然后执行,而不是函数里调用函数,这样就避免了递归执行
                    function sum(x, y) {
                        if (y > 0) {
                            return sum.bind(null, x + 1, y - 1); // sum函数每次执行都会返回自身的另一个版本
                        } else {
                            return x;
                        }
                    }
                    sum(1, 100000000); // 现在调用就不会发生调用栈溢出;


                }

            }
        </script>
        <script class='5_数组的扩展'>
            function T1() {
                function T1_1() {
                    // 1.扩展运算符...[], 可用于展开一个数组,只有当函数调用时,扩展运算符才能放在圆括号中,否则会报错
                        // 可用于将unicode字符串转换为数组: var arr = [...'x\uD83D\uDE80y']
                        // 所有实现了Iterator接口的对象都可以用改运算符转换为数组,Map 和 Set 结构，Generator 函数
                    // 2.在一些方法中参数不能为数组,要利用apply方法将数组作为参数传入
                    Math.max.apply(null, [1, 2, 3, 4]); // max方法的参数不能为数组,可用该方法传入
                    Array.prototype.push.apply([1, 2, 3], [2, 3, 4]); // [1, 2, 3, 2, 3, 4], 利用push函数合并数组
                    // 0.有了扩展运算符可以不用apply方法就实现上述效果
                    Math.max(...[1, 2, 3]);
                    arr1.push(...arr2);
                    // 3.数组复制: 0.
                    arr.slice();
                    arr.concat();
                    arr.toStringify()
                    // 0.ES6: 下述两种方式a2都是a1的克隆
                    ar1 = [...ar2];
                    [...a2] = a1;
                    // 4.数组合并,浅拷贝
                    [...arr, ...ar1]

                    // 与解构赋值结合
                }

                function T1_2() {
                    // 方法
                    Array.from(target, x => x) // 可用于将类数组和可遍历对象转换为真正的数组;只要是部署了Iterator接口的数据结构都可以被转换, 如dom操作返回的NodeList集合和函数的arguments对象都可转换为数组;
                        // 可将字符串转换为数组,能正确处理各种Unicode字符,效果与...类似,第二个参数用于处理数据
                        // 可将set转换为数组
                    Array.of(1,2,3) // [1,2,3] 用于将一组值转换为数组, 替代Array()或new Array(); 它的行为非常统一,有几个参数生成的数组就有几个值,无参返回空数组
                        // 作用: 弥补构造函数Array()的不足,因为参数个数的不同会导致Array()的行为有差异
                    [0].copyWithin(target,start,end); // 在当前数组内部,将指定位置的成员复制到其他位置,开始结束位置如果是负数表示从末尾开始计算

                    [0].find((value,index,arr) => value < 0,person); // 用于找出第一个符合条件的数组成员,内部函数可接受三个参数,分别为当前值,当前索引和数组对象,find和findIndex都可以发现NaN
                    [0].findIndex((value,index,arr) => value > 3,person); // 用法与find相同,所有成员都不符合时返回-1, 这两个方法的第二个参数用于指定内部的this指向
                        [NaN].indexOf(NaN) // -1, 无法识别
                        [NaN].findIndex(x => Object.is(NaN,x)) // findIndex方法可借助is方法识别数组的NaN成员

                    ['a','b'].fill(7); // [7,7] 填充一个数组,数组中已有的元素会被全部抹去,可接收三个参数,一参为要填充的值,二参三参为填充的起始结束位置
                        // 如果赋值为对象则被赋值的是同一个内存地址的对象,而不是深拷贝的对象 
                    [].entries(); // 返回数组键值对的遍历器,包括下面两个方法都返回一个遍历器对象,可以用for...of循环遍历, 
                    [].keys(); // 返回键值遍历器
                    [].values(); // 返回值的遍历器
                        for(let index of ['1'].keys()) console.log(index);
                        for(let [index,ele] of ['1'].keys()) console.log(index,ele); // 解构赋值

                    [2].includes(1,0); // 返回一个布尔值,标识数组是否包含给定的值,第二个参数标识搜索的起始位置
                        // 之前用indexOf实现同样的功能, indexOf缺点: 内部使用 === , 会导致对NaN的误判,includes可以正确判断NaN
                        [NaN].indexOf(NaN); // -1
                    flat(2); // 数组的成员是数组时用该方法将嵌套的多维数组拉平为一维数组, 接收一个整数作为参数,表示要拉平的层数,默认为1,如果不管有多少层嵌套都要转成一维数组,可用Infinity关键字作为参数
                        [1,2,,[3,4]].flat(); // [1,2,3,4],不影响原数组,返回新数组,如果有空位会跳过
                    flatMap((value,index,arr) => value,person); // 对原数组的每个成员执行一个函数,然后对返回值组成的数组执行flat()方法,不改变原数组,二参指定要绑定的this指向
                }
                
                function T1_3() {
                    // ES5数组方法对空位的处理和ES6的新方法
                    // 数组的空位指这个位置没有任何值,Array构造器返回的数组为空位数组
                        Array(3); // [, , ,]
                        0 in [undefined, undefined, undefined] // true
                        0 in [, , ,] // false
                    
                    // ES5: 
                        // forEach(), filter(), reduce(), every() 和some()都会跳过空位。
                        // map()会跳过空位，但会保留这个值
                        // join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。
                    // ES6: 
                        // 将空位转为undefined
                }
            }
        </script>

        <script class="6_对象的扩展">
            // 未看内容: 方法的name属性     http://es6.ruanyifeng.com/#docs/object#%E6%96%B9%E6%B3%95%E7%9A%84-name-%E5%B1%9E%E6%80%A7
            function T6() {
                // T6_1 --> 对象属性简洁表示, 属性名表达式,属性的可枚举性
                // T6_2 --> 遍历对象属性的方法，super
                // T6_3 --> 对象的解构赋值
                // T6_4 --> 对象的新增方法
                function T6_1() {
                    // 对象只接受字符串做键名
                    // 1.对象属性的简洁表示, 简洁写法的属性名总是字符串
                        // 0.对象中直接写入变量
                        const foo = 'bar';
                        const baz = {foo}; // baz --> {foo: 'bar'}, 在对象中直接写入变量时属性名为变量名,属性值为变量的值

                        function fn(x,y) {
                            return {x,y} // 等同于{x: x, y: y};
                        }

                        // 0.方法的简写
                        const o ={
                            method() {}, // 两种方式等价
                            mm: function() {}
                        }

                    // 2.属性名表达式
                        // ES5: 
                            obj.foo = true;
                            obj['a'+'b'] = 123;
                        // ES6: 字面量方式定义对象(大括号)时可以使用变量
                            let prop = 'foo';
                            obj = {
                                [prop]: true,  // 等价于 'foo': true
                                ['a'+'b']: 123
                            }
                            obj[prop] === obj['foo']
                        // 表达式还可用于定义方法名
                            let obj = {
                                ['h'+'ello']() {
                                    return 'hi';
                                }
                            }
                            obj.hello(); // hi
                        // 属性名表达式不可与简洁表示法一同使用,会报错
                            const foo = 'bar';
                            // const baz = {[foo]};  !!!!!错误写法!!!!!!
                        //  属性名表达式如果是一个对象默认会转成字符串'[object object]'
                            const keyA = {a: 1};
                            const keyB = {b: 2};
                            const myObject = {
                                [keyA]: 'valueA',
                                [keyB]: 'valueB'
                            };
                            myObject // {[object Object]: "valueB"}     最终只会有一个[object Object], 重复属性名
                    // 3.属性的可枚举性和遍历,ES6规定，所有Class的原型方法都是不可枚举的
                        // 对象的每个属性都有一个描述对象，用来控制该属性的行为
                            Object.getOwnPropertyDescriptor // 用该方法获取属性的描述对象
                        // 描述对象的enumerable属性代表可枚举性，如果该属性为false，则表示该属性会被一些方法忽略如：
                            // for...in循环：只遍历对象自身的和继承的可枚举的属性。
                            // Object.keys()：返回对象自身的所有可枚举的属性的键名。
                            // JSON.stringify()：只串行化对象自身的可枚举的属性。
                            // Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。

                }
                
                function T6_2() {
                    // 1.遍历对象的属性
                        for(ele in obj) {} // 遍历对象自身和继承的可枚举属性，不包括Symbol属性
                        Object.keys(obj) // 返回一个数组，包括对象自身的（不含继承的）可枚举属性（不含Symbol）的键名
                        Object.getOwnPropertyNames(obj) // 返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）的键名
                        Object.getOwnPropertySymbols(obj) // 返回一个数组，包含对象自身的所有Symbol属性的键名
                        Reflect.ownKeys(obj) // 返回一个数组，包含对象自身的所有键名，不论键名是symbol或字符串，也不论是否可枚举
                        // 以上几种方法遍历对象的键名都遵循相同的规则：
                        // 0.首先遍历所有数值键，按照数值升序排列。
                        // 0.其次遍历所有字符串键，按照加入时间升序排列。
                        // 0.最后遍历所有 Symbol 键，按照加入时间升序排列。
                    // 2.super关键字，指向当前对象的原型对象，super关键字标识原型对象时只能用在对象的方法中，不然会报错
                        const obj = {foo: () => super.foo} // 报错，super用在一个函数里，然后赋值给foo属性
                        const obj = {foo: function () {return super.foo}} // 报错，super用在一个函数里，然后赋值给foo属性
                        const obj = {foo(){return super.foo}} // 只有用对象方法的简写法才能让js引擎认为定义的是对象的方法

                }
            
                function T6_3() {
                    // 1.对象的解构赋值+扩展运算符
                        // 解构赋值的拷贝是浅拷贝，如果一个键的值是符合类型的值，拷贝的是这个值的引用
                            let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; // x:1, y:2, z:{a:3,b:4}
                        // 对象的结构赋值要求右侧是一个对象，所以如果等号右边是undefined或null就会报错，因为它们无法转为对象
                            {...1} // 扩展运算符后面不是对象会自动转为对象（包装类Number(1)）,返回空对象
                            {...'hello'} // 如果是字符串会转成类似数组的对象{0:'h',1:'2'...}
                        // 用扩展运算符合并两个对象
                            let ab = {...a,...b}; 
                            // 等同于
                            let ab = Object.assign({},a,b)
                        // 自定义的属性放在扩展运算符后面则扩展运算符内部的同名属性会被覆盖掉,可用于修改现有对象的部分属性
                            let newObj = {
                                ...oldObj,
                                name: 'new name' // 继承oldObj的所有属性并覆盖name属性
                            }
                        // 自定义属性放在扩展运算符前面就变成了新对象的默认属性值
                            let newObj = {
                                name: 'new name', // 如果oldObj里有name属性则被覆盖，没有的话就是这个
                                ...oldObj
                            }
                        // 扩展运算符后可跟表达式
                            const obj = {
                                ...(x > 1 ? {a: 1} : {}),
                                b: 2,
                            }
                        // 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。
                            let aWithXGetter = {
                                ...a,
                                get x() {
                                    throw new Error('not throw yet'); // 只定义，未被执行
                            }};
                            let runtimeError = {
                                ...a,
                                ...{
                                    get x() {
                                            throw new Error('throw now'); // 会抛出错误，因为 x 属性被执行了
                                    }}
                                };
                            }

                function T6_4() {
                    // 1.对象的新增方法
                        Object.is(one,two); // 同值相等算法的部署，比较两个值是否严格相等
                            // 与===基本一致，不同： +0不等于-0，NaN等于自身
                        Object.assign(target,source1,source2); // 合并对象，将源对象的所有可枚举属性复制到目标对象
                            // 一参为目标对象（合并的结果，可为空对象），后面都是源对象，如果有同名属性后面覆盖前面的（即使同名属性的值都是对象）
                            // 只有一个参数返回该参数，参数不是对象会先转为对象，undefined和null无法转换为对象，用这两个作为参数会报错
                            // 非对象值除了字符串会作为数组被传入对象其他都没有效果，属性名为Symbol值的属性也会被Object.assign拷贝
                            // Object方法是浅拷贝，对象拷贝的是引用
                            Object.assign([1,2,3],[4,5]); // [4,5,3]  处理数组时会把数组视为对象，索引值为属性名，后来的同位置的值会替换
                                // 用在数组上相当于替换同位置的值
                            // 用途： 1.为对象添加属性和方法； 2.克隆对象（拷贝到空对象，浅拷贝）； 3.合并对象； 4.为属性设置默认值（新值在后面可替换）
                        Object.setPrototypeOf(obj,prototype); // 设置对象的prototype对象，返回参数对象本身
                        Object.getPrototypeOf(obj); // 获取一个对象的原型对象
                        Object.fromEntries([['foo','bar'],['baz',42]]); // {foo:'bar','baz',42} 把一个键值对转为对象
                            // 作用： 把Map结构转为对象
                            const map = new Map().set('foo', true).set('bar', false);
                            Object.fromEntries(map)
                            // { foo: true, bar: false }
                }


            }
        </script>

        <script class="7_Symbol">
            // 引入原因： 多对象合并时，如果出现同名属性则会被覆盖，ES5的对象属性名都是字符串，很容易造成冲突，Symbol可以保证每个属性的名字都是独一无二的
            // Symbol是ES6引入的一种原始类型的数据，表示独一无二的值，是第七种数据结构
            // 应用于switch， 消除魔术字符串（多次出现的具体字符串，不利于维护，应该定义为一个变量）
            const T7 = {
                // T7_1: 定义，属性
                // T7_2: 作为属性名，获取，使用同一个Symbol
                // T7_3: 内置Symbol值
                T7_1() {
                    let s = Symbol('str'); // 不能用new定义Symbol，因为Symbol是一个原始类型的值而不是对象
                        // 接收一个字符串作为参数，表示对symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
                        // 相同参数的Symbol的值不相同，因为参数只是一个描述，如果参数是一个对象，则调用该对象的toString方法转为字符串
                        // Symbol不能喝其他类型的值进行运算，会报错
                    s.toString(); // 'Symbol(str)' , 可以显式的转为字符串（不能隐式转换，因为不能参与运算）
                        // 可转为布尔值但是不能转为数字
                    s.description; // 用于获取Symbol的描述
                },
                T7_2() {
                    // 1.由于每个Symbol值都是不相等的，所以以Symbol值为属性名就不会有冲突
                    // 2.用一下三种方式设置Symbol为属性名
                        let s = Symbol();let a = obj;
                        a[s] = 'hello';
                        let a = {
                            [s]: 'hello'
                        }
                        Object.defineProperty(a,s,{value: 'hello'}); 
                    // 3.Symbol作为对象属性名时，不能用点运算符,点运算符后总是字符串，所以不会读取s作为标识名指代的那个值
                        a.s = 'hello'; // 相当于a['s'] = 'hello'， 属性名为字符串's'而不是s变量对应的Symbol值
                    // 4.Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。
                    // 5.遍历Symbol属性名，只能用下面方法
                        Object.getOwnPropertySymbols(obj); // 获取指定对象的所有Symbol属性名，返回值为一个数组
                        Reflect.ownKeys(obj); // 可返回所有类型的键名
                        // 由于以Symbol值作为名称的属性，不会被常规方法遍历到，可以利用这个特性为对象定义一些非私有的，但又希望只用于内部的方法
                    // 6.使用同一个Symbol值,for方法生成的Symbol值是全局环境的，可以在不同的iframe中取到同一个值
                        Symbol.for(); // 接收一个字符串作为参数，然后搜索有没有以改参数作为名称的Symbol值，如果有就返回这个值，否则就以参数为描述创建一个Symbol值
                            // Symbol.for()与Symbol()两种写法都会生成新的Symbol，区别在于，前者会被登记在全局环境中供搜索，后者不会
                            // Symbol.for每次调用先检查给定的key是否已存在，不存在时才会新建一个值
                            // Symbol()， 每次执行都会创建一个新的Symbol值，这种写法没有登记机制，也就无法搜索
                        Symbol.keyFor(); // 返回一个已登记的symbol值的key（描述）
                            Symbol.keyFor(Symbol('foo')); // 返回undefined，因为用Symbol()形式创建的值没有登记机制
                            Symbol.keyFor(Symbol.for('foo')); // 'foo'
                        
                },
                T7_3() {
                    // 内置symbol值
                    Symbol.hasInstance; // 对象的属性，指向一个内部方法，当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法
                        foo instanceof Foo; // 实际调用的是 Foo[Symbol.hasInstance](foo)。
                    Symbol.isConcatSpreadable; // 数组的属性，等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。
                        arr[Symbol.isConcatSpreadable]; // 默认为undefined，为true时也可以展开，等于false时不可被展开，可手动更改
                        // 类数组的行为刚好相反，arr[Symbol.isConcatSpreadable]为true时才可以展开
                    Symbol.species; // 对象的属性，指向一个构造函数，创建衍生对象时会使用该属性
                        class MyArray extends Array {}; // MyArray继承Array
                        const a = new MyArray(1, 2, 3);
                        const b = a.map(x => x);
                        const c = a.filter(x => x > 1);

                        b instanceof MyArray // true, b和c都是MyArray的实例
                        c instanceof MyArray // true

                        class MyArray extends Array {
                            static get [Symbol.species]() { return Array; } // 定义Symbol.species属性，创建衍生对象时就会使用这个属性返回的函数作为构造函数，必须用get取值器来设置
                        }
                    Symbol.match; // 对象的属性，指向一个函数，当执行str.match(myObject)时，如果改属性存在，会调用发，返回该方法的返回值
                        String.prototype.match(regexp)
                        // 等同于
                        regexp[Symbol.match](this);
                    Symbol.replace; // 对象的属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。
                        String.prototype.replace(searchValue, replaceValue)
                        // 等同于
                        searchValue[Symbol.replace](this, replaceValue)

                }

            }
        </script>

        <script class="8_Set & Map">
            const T8 = {
                // T8_1: 特性
                // T8_2: 属性和方法
                // T8_3: weakSet
                // T8_4: Map
                T8_1() {
                    // 1.用构造函数生成一个Set
                        let s = new Set();
                        let s1 = new Set([1,2,3,4]); // Set函数可接收一个数组活具有iterable接口的其他数据结构作为参数进行初始化
                    // 2. Set数据结构类似于数组，但是其成员的值都是唯一的，没有重复的值，可用于去重字符串和数组
                        [1,2,2,2,3,3].forEach(ele => s.add(ele)); // [1,2,3], 利用set给数组去重
                        [...new Set('ababbc')].join(''); // 去除字符串里面的重复字符
                        Array.from(new Set(array)); // 数组去重， Array.from()可以把set转换为数组，去除数组重复成员的新方法
                        arr = [...new set(arr)]
                    // 3. 向set加入值的时候不会发生类型转换，所以5和'5'是两个不同的值，set内的相等判断类似===，区别在于set认为NaN等于自身
                },
                T8_2() {
                    // 1.属性
                    Set.prototype.constructor // 构造函数，默认就是Set函数。
                    Set.prototype.size // 返回Set实例的成员总数。

                    // 2.操作方法（操作数据）
                        Set.prototype.add(value) // 添加某个值，返回 Set 结构本身。
                        Set.prototype.delete(value) // 删除某个值，返回一个布尔值，表示删除是否成功。
                        Set.prototype.has(value) // 返回一个布尔值，表示该值是否为Set的成员。
                        Set.prototype.clear() // 清除所有成员，没有返回值。

                    // 3.遍历方法,set的遍历顺序就是插入顺序，使用set保存一个回调函数列表，调用时就能保证按照添加顺序调用
                        Set.prototype.keys() // 返回键名的遍历器， set结构没有键名，或者说是键名和键值是同一个值，所以keys和values方法的行为完全一致
                        Set.prototype.values() // 返回键值的遍历器
                        Set.prototype.entries() // 返回键值对的遍历器
                        Set.prototype.forEach() // 使用回调函数遍历每个成员，与数组的forEach方法相同
                        for(let x of set){} // 可用for...of循环来遍历set
                        [...set] // 可用扩展运算符展开set
                            arr = [...new set(arr)]; // 用扩展运算符给数组去重
                            set = new Set([...set].map(x => x*2)) // 变相使用数组的map方法
                },
                T8_3() {
                    // weakSet结构与Set类似，也是不重复的值的集合，与Set的区别：
                        // 1.weakSet的成员只能是对象，不能是其他类型的值
                        // 2，weakSet中的对象都是弱引用，也就是说，如果其他对象都不再引用该对象，name垃圾回收机制会自动回收改对象所占用的内存
                        // 4.因为wekaSet的成员是弱引用所以其成员会随时系哦啊哈斯，ES6规定weakSet不可遍历
                    // 方法：
                        WeakSet.prototype.add(value) // 向 WeakSet 实例添加一个新成员。
                        WeakSet.prototype.delete(value) // 清除 WeakSet 实例的指定成员。
                        WeakSet.prototype.has(value) // 返回一个布尔值，表示某个值是否在 WeakSet 实例之中。
                    // 应用： 存储DOM节点，而不用担心这些节点从文档移除时会引发内存泄漏
                },
                T8_4() {
                    // 传统的对象只接收字符串作为键名，非字符串会被自动转换
                    // Map可以接收所有类型的值当做键
                    // 对同一个键值多次赋值后面会覆盖前面的
                    // 如果读取一个位置的键返回undefined
                    // !!只有对同一个对象的引用Map才将其视为同一个键
                    // 对于简单类型的值，只要两个值严格相等，Map就将其视为一个键
                    // undefined和null是两个不同的键，虽然NaN不严格等于自身，但Map将其视为同一个键
                    const m = new Map([['name','zkb'],['title','gg']]); // 构造函数可接收一个数组作为参数，数组的成员是一个个表示键值对的数组
                    const m1 = new Map(new Set(['name','zkb'],['title','gg'])); // 利用Set来生成新的Map，任何具有iterator接口且每个成员都是双元素的数组的数据结构都可作为Map构造函数的参数

                    // 1.Map的属性
                        map.size; // 返回Map结构的成员数量
                        Map.prototype.set(key,value); // 设置键名key对应的值value，然后返回整个Map结构，如果key已经有值则覆盖，没有则新建
                            map = new Map().set(1,'a').set(2,'b'); // 返回的是当前Map对象，所以可以用链式写法
                        Map.prototype.get(key); // 读取key对应的键值，找不到key则返回undefined
                        Map.prototype.has(key); // 返回一个布尔值，表示某个键是否在当前Map对象中
                        Map.prototype.delete(key); // 删除某个键，成功返回true，失败返回false
                        Map.prototype.clear(); // 清除所有成员，没有返回值
                    
                    // 2.Map遍历方法,遍历顺序是插入顺序
                        Map.prototype.keys() // 返回键名的遍历器。
                        Map.prototype.values() // 返回键值的遍历器。
                        Map.prototype.entries() // 返回所有成员的遍历器。
                        Map.prototype.forEach() // 遍历 Map 的所有成员。
                    // 3.借助数组方法进行操作
                        // 转为数组，比较快速的方法是使用扩展运算符
                        [...map.keys()];
                        [...map];
                        [...map].filter(([k, v]) => k < 3);
                    // 4.与其他结构的转换
                        // 转为Map
                            new Map(arr); // 数组： 传入构造函数
                            // 对象： 遍历对象用map.set(k,v)给map添加键值对
                            // json: 正常情况下所有键名都是字符串，用JSON.parse(jsonStr)转换为对象后传入new Map()
                            // json: 如果是这种情况jsonStr = "[[true,'2'],[a,'3'],[]]" , 会被一一对应的以键值对形式生成Map

                        // Map转换为其他
                            [...map]; // 数组： 扩展运算符
                            // 对象： 遍历map用新对象接收，如果键名为非字符串会被转换为字符串
                            // json: 如果键名都是字符串转为对象后用JSON.stringify()，键名有非字符串可以先转为数组再转为json（JSON.stringify()）
                    // 5.WeakMap
                        // 与Map的区别： 只接收对象作为键名（null除外），不接受其他类型的值作为键名， WeakMap的键名所指向的对象不计入垃圾回收机制
                        // 作用： 有时我们想再某个对象上存放一些数据，但是这会形成对于这个对象的引用，一旦不需要这个对象，必须手动删除这个引用，不然垃圾回收机制就不会释放对应的内容，不写则会造成内存泄露
                        // 应用场景： 在DOM元素上添加数据时用WeakMap，当该DOM元素被清除，其所对应的WeakMap记录会自动被移除
                        // WeakMap的键对应的对象，可能在将来消失，有助于防止内存泄露
                        // tips： 键值是正常引用，键名为弱引用
                        // 操作与WeakSet类似
                }
            }
        </script>

        <script class="9_proxy9拦截器0">
            // t1: 介绍，创建
            // t2: 支持的拦截方法
            const proxy = {
                // Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程
                // 相当于在原始方法上加上一个拦截（重写原始方法）
                T_1() {
                    // 1.创建方法：构造函数
                        var proxy = new Proxy(target, handler); // target是要拦截的目标对象，handler参数也是一个对象，用来制定行为
                    // 2.只有访问proxy实例操作才会起作用，而不是目标对象
                        var object = { proxy: new Proxy(target, handler) }; // 将proxy对象设置到object.proxy属性，从而再object对象上调用
                    // 3.可以将proxy实例设置为其他对象的原型对象来继承被拦截操作
                    // 4.同一个拦截器函数，可以设置拦截多个操作
                },
                T2() {
                    // proxy支持的拦截操作一共十三种 
                    get(target, key, proxy); // 拦截某个属性的读取操作，接收三个参数，依次为目标对象，属性名和proxy实例本身（严格来讲是操作行为所指向的对象）
                        // 利用proxy修改get，实现方法的链式调用(累计之前的方法到执行栈中，调用规定方法后依次执行) 
                        function pipe() {
                            let pipe = (function () {
                                return function (value) {
                                    // 1.保存非get的函数
                                    var funcStack = [];
                                    // 2.生成拦截器
                                    var oproxy = new Proxy({}, {
                                        // 3.重写get（取值操作）
                                        get(pipeObject, fnName) {
                                            if (fnName === 'run') {
                                                // 4.如果当前操作的函数名为run时执行栈中的函数，利用Array.prototype.reduce函数调用所有函数
                                                return funcStack.reduce(function (val, fn) {
                                                    return fn(val);
                                                }, value);
                                            }
                                            // 5.如果当前方法名不是‘run’则将该方法加入执行栈中
                                            funcStack.push(window[fnName]);
                                            // 6.返回拦截器函数
                                            return oproxy;
                                        }
                                    });
                                    // 7.返回拦截器函数（pipe函数执行的返回值）
                                    return oproxy;
                                }
                            })();
                            var double = n => n * 2;
                            var pow = n => n * n;
                            var reverseInt = n => n.toString().split("").reverse().join("") | 0;
                            pipe(3).double.pow.reverseInt.run; // 63
                        }
                    
                    set(target, key, value, proxy); // 拦截赋值操作，参数： 目标对象，属性名，属性值，proxy实例本身
                        // 2.利用proxy修改set，控制赋值操作时值的范围
                        function proxySet() {
                            let validator = {
                                set(obj, key, value) {
                                    // 1.规定age属性的值
                                    if (key === 'age') {
                                        // 判断是否为整数
                                        if (!Number.isInteger(value)) {
                                            throw new TypeError('不是整数')
                                        }
                                        if (value > 200) {
                                            throw new RangeError('大于200')
                                        }
                                    }
                                    // 满足条件的age及其他值直接保存
                                    obj[key] = value;
                                }
                            }
                            let person = new Proxy({}, validator);
                            person.age = 300; // 报错
                        }
                
                    apply(target,targetContext,targetArguments); // call与apply相同，拦截重定向操作，参数： 目标对象，目标对象的this（上下文对象），目标对象的参数数组
                    
                    has(target,key); // 拦截HasProperty操作，判断对象是否具有某个属性时才会生效，典型的是in运算符，参数： 目标对象，需要查询的属性名
                        // 使用has方法时隐藏某些属性不被in运算符发现
                        function proxyHas() {
                            var handler = {
                                has(target, key) {
                                    if (key[0] === '_') {
                                        return false;
                                    }
                                    return key in target;
                                }
                            };
                            var target = { _prop: 'foo', prop: 'foo' };
                            var proxy = new Proxy(target, handler);
                            '_prop' in proxy // false
                        }
                        
                    construct(target, args, newTarget); // 拦截new命令,参数： 目标对象，构造函数的参数对象， 创造实例对象时，new命令使用的构造函数，必须返回一个对象，否则会报错

                    deleteProperty(target, key); // 拦截delete操作，如果这个方法抛出错误或者返回false，当前熟悉就无法被delete删除
                        // 目标对象自身的不可配置的属性不能背删除，否则会报错

                    defineProperty(target, key, descriptor); // 拦截Object.defineProperty（赋值），如果返回false则无法添加属性

                    getOwnPropertyDescriptor(target, key); // 拦截Object.getOwnPropertyDescriptor(),查询制定对象的属性描述符，返回一个属性描述对象或者undefined。

                    getPrototypeOf(target); // 拦截获取对象原型的操作，返回值必须为null或一个对象如：
                        Object.prototype.__proto__
                        Object.prototype.isPrototypeOf()
                        Object.getPrototypeOf()
                        Reflect.getPrototypeOf()
                        instanceof {}

                    isExtensible(target); // 拦截Object.isExtensible操作,判断一个对象是否是可扩展的（是否可以在他上面添加新的属性）。

                    ownKeys(); // 拦截对象自身属性的读取操作
                        Object.getOwnPropertyNames()
                        Object.getOwnPropertySymbols()
                        Object.keys(); // 会被ownKeys自动过滤的属性： 1.目标对象上不存在的属性，2.属性名为Symbol，3.不可遍历（enumerable）的属性
                        // for...in循环

                    preventExtensions(); // 拦截Object.preventExtensions()，让一个对象变得不可扩展（不能添加新属性）。该方法必须返回一个布尔值，否则会被自动转为布尔值。

                    setPrototypeOf(); // 拦截Object.setPrototypeOf方法,设置一个对象的原型到另一个对象或null。
                },
            
                T3() {
                    Proxy.revocable(); // 返回一个可取消的proxy实例
                    // 在proxy代理的情况下，目标对象内部的this关键字会指向proxy代理
                }
            }
        </script>

        <script class="10_Reflect(API)">
            // T1: 介绍
            // T2：方法
            const Reflect = {
                T1() {
                    // 1.与Proxy一样，是为了操作对象而提供的API
                    // 2.目的： 保存语言内部的方法，将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。目前一些方法同事定义在Object与Reflect上
                        // 让Object操作都变成函数行为，有些Object的操作是命令式的，如in操作符和delete操作符
                        Reflect.has(obj,name); // 判断obj是否存在在键名为name的属性， 替代in
                        Reflect.deleteProperty(obj,name); // 删除对象中的属性，替代delete
                    // 3.Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。
                },
                T2() {
                    Reflect.apply(func, thisArg, args); // 等同于Function.prototype.apply.call(func, thisArg, args)，绑定this对象后执行给定函数

                    Reflect.get(target, name, receiver); // 查找并返回target的那么属性，没有则返回undefined，如果name属性部署了读取函数（getter），则读取函数的this绑定receiver

                    Reflect.set(target, name, value, receiver); // 设置对象的属性

                    Reflect.has(obj, name); // 对应in运算符，一参不是对象会报错

                    Reflect.deleteProperty(obj, name); // 对应delete运算符，删除成功或被删除的属性不存在返回true，删除失败，被删除的属性依然存在返回false

                    Reflect.construct(target, args); // 对应 new target(...args), 提供了不使用new来调用构造函数的方法，一参不是函数会报错

                    Reflect.getPrototypeOf(obj); // 对应Object.getPrototypeOf(obj)，用于读取对象的__proto__属性，

                    Reflect.setPrototypeOf(obj, newProto); // 对应Object.setPrototypeOf(obj,newProto)方法，设置对象的原型，返回一个布尔值标识是否设置成功

                    Reflect.defineProperty(target, propertyKey, attributes); // 等同于Object.defineProperty(), 用来为对象定义属性

                    Reflect.getOwnPropertyDescriptor(target, propertyKey) ; // 等同于Object.getOwnPropertyDescriptor,用于得到指定属性的描述对象

                    Reflect.isExtensible (target); // 对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。

                    Reflect.preventExtensions(target); // 对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。

                    Reflect.ownKeys (target); // 返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。
                }
            }
            
        </script>

        <script class="11_Promise(异步)">
            // 异步编程的解决方案，是一个容器（对象），保存了异步操作的结果
            // 无法取消promise,一旦新建就会立即执行
            // 并不提供新的功能而只是将回调函数的嵌套改为链式调用
            // T1：用法
            // T2: 方法
            const Promise = {
                T1() {
                    // 用法，用Promise构造函数生成,接收一个函数为参数，函数有两个参数，为js引擎提供的两个函数
                        const promise = new Promise(function(resolve,reject){
                            resolve(); // 状态为成功时调用
                            reject(); // 状态为失败时才会调用,如果状态为成功则不调用
                        })
                    // 应用: 加载图片,将图片的加载写成一个Promise,一单完成加载,Promise的状态就发生变化
                        const preloadImage = function (path) {
                            return new Promise(function (resolve, reject) {
                                const image = new Image();
                                image.onload  = resolve; // 监听对应事件
                                image.onerror = reject; // 监听对应事件
                                image.src = path;
                            });
                        };

                },
                T2() {
                    Promise.prototype.then(resolve,reject); // 给Promise实例添加状态改变时的回调函数,第一个参数为成功时的,第二个为失败
                        // then方法返回的是新的Promise实例(不是原来的实例),因此可以用链式写法分别绑定
                        new Promise((r,j) => {}).then(() =>{}).then(() => {}); // 依次指定两个回调函数,第一个回调函数完成后会将结果作为参数传入第二个回调函数
                        // 采用链式的then可以指定一组按次序调用的回调函数,这时如果前一个回调函数返回的还是一个Promise对象(有异步操作),这时后一个回调函数就会等改Promise对象的状态发生变化时才会被调用
                        getJSON("/post/1.json").then(function(post) { // getJSON为一个promise对象
                            return getJSON(post.commentURL);
                        }).then(function (comments) {
                            console.log("resolved: ", comments);
                        }, function (err){
                            console.log("rejected: ", err);
                        });
                    Promise.prototype.catch(() => {}); // 该方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。
                        // Promise内部的错误不会影响到Promise外部的代码
                        const promise = new Promise(function(resolve, reject) {
                            throw new Error('test');
                        });
                        promise.catch(function(error) {
                            console.log(error);
                        });
                    Promise.prototype.finally(() => {}); // 指定不管Promise对象最后状态如何都会执行的操作(ES2018引入)
                        // finally方法的回调函数不接受任何参数,即没法知道前面的Promise状态是fulfilled还是rejected,也就是说finally里面的操作应该是与状态无关的,不依赖与promise的执行结果
                        // finally本质上是then方法的特例(给成功和失败的回调函数做同样的操作,即都执行同一个回调函数)
                    Promise.all(); // 将多个Promise实例包装成一个新的Promise实例,不是Promise的会调用Promise.resolve方法
                        const p = Promise.all([p1, p2, p3]); // 参数可以不是数组但必须有Iterator接口且返回的每个成员都是Promise实例
                        // p的状态由成员决定,如果成员的状态都为fulfilled,p的状态才是fulfilled,成员的返回值组成一个数组传递给p的回调函数
                        // 只要成员有一个为rejected,p的状态就是rejected,此时第一个被reject的实例的返回值会传递给p的回调函数
                    Promise.race(); // 将多个Promise实例包装成一个新的Promise实例
                        const p = Promise.race([p1, p2, p3]); // 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。
                    Promise.resolve(); // 将现有对象转为Promise对象
                        // 参数为Promise对象: 不做操作,返回该实例
                        // 参数为thenable对象(具有then方法的对象): 将该对象转为Promise对象,立即执行then方法
                            let thenable = {
                                then: function(resolve, reject) {
                                    resolve(42);
                                }
                            };
                        // 参数不是具有then方法的对象，或根本就不是对象: 返回一个新的Promise对象,状态为resolved
                        // 没有参数:返回一个新的Promise对象,状态为resolved
                    Promise.reject(); // 返回一个新的Promise实例,该实例的状态为rejected
                    Promise.try(); 
                }
            }
        </script>

        <script class="12_Iterator（遍历器）">
            // 一种统一的接口机制，只要部署了Iterator接口就可以用for...of和while循环遍历
            // 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）
            // 对象没有部署Iterator原因: 对象是非线性的数据结构,不确定属性的遍历顺序,部署遍历器接口等于部署一种线性转换,对象部署遍历器接口相当于当做Map结构使用
            // T1:遍历过程,模拟实现,遍历原理(Symbol.iterator属性),默认调用Iterator的场合
            // T2: for...of循环
            const Iterator = {
                T1() {
                    // 1.Iterator遍历过程
                        // 0.创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。
                        // 0.第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。
                        // 0.第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。
                        // 0.不断调用指针对象的next方法，直到它指向数据结构的结束位置。
                        // 0.每次调用next()方法,都返回一个包含value和done两个属性的对象,value是当前成员的值,done属性是一个布尔值标识遍历是否结束
                    // 2.模拟实现
                        var it = makeIterator(['a', 'b']); // 获取一个遍历器对象
                        function makeIterator(array) {
                            var nextIndex = 0;
                            return {
                                next: function() {
                                    return nextIndex < array.length ?
                                        {value: array[nextIndex++], done: false} :
                                        {value: undefined, done: true};
                                }
                            };
                        }
                    // 3.Iterator接口部署在数据结构的Symbol.iterator属性上,也就是说一个数据结构只要有Symbol.iterator属性就可认为是可遍历对象(可使用for...of),
                        // 可在原型链上编写也可在实例上,必须返回一个遍历器对象(包括next方法和done属性)
                        String.prototype[Symbol.iterator]; // 部署了Iterator接口,返回一个方法
                        Array.prototype[Symbol.iterator]; // 部署了Iterator接口,返回一个方法
                        Object.prototype[Symbol.iterator]; // 没有部署Iterator接口,返回undefined
                        NodeList.prototype[Symbol.iterator] = [][Symbol.iterator]; // 类数组可以直接饮用数组的Iterator接口
                    // 4.部署了Iterator接口的数据结构
                        // 0.Array
                        // 0.Map
                        // 0.Set
                        // 0.String
                        // 0.TypedArray
                        // 0.函数的 arguments 对象
                        // 0.NodeList 对象
                        let arr = [1,2,3];
                        let it =  arr[Symbol.iterator](); // 这样可得到arr的遍历器对象
                    // 5.默认调用Iterator接口的场合
                        // 0.对数组和set结构进行结构赋值时
                            let set = new Set().add('a').add('n');
                            let [x,y] = set;
                        // 0.扩展运算符,任何部署了Iterator接口的数据结构都可以通过这种方式转换为数组
                        // 0.for...of
                        // 0.Array.from()
                        // 0.Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）
                        // 0.Promise.all()
                        // 0.Promise.race()
                    // 6.遍历器对象的return()和throw();
                        // 自己写遍历器对象生成函数时,naxt是必须的,return和throw是可选的
                        // return方法的使用场合是,如果for...of循环提前退出(出错或break)就会调用return方法,如果一个对象在完成遍历钱需要清理或释放资源,就可以部署return方法
                        // throw方法配合Generator函数使用
                    // 1.for...of循环
                        // 一个数据结构只要部署了Symbol.iterator属性,就被视为具有Iterator接口,就可以用forof循环遍历他的成员
                        // 也就是说for...of循环内部调用的是数据结构的Symbol.iterator方法
                        // 适用范围: 数组,set,map,类数组如arguments对象,DOM, NodeList对象,Generator对象,字符串
                },
            }
        </script>

        <script class="13_Generator函数(生成器)">
            const Generator = {
                // T1: 介绍,创建及调用,yield表达式,与iterator关系,for...of循环
                // T2: 原型上的方法,next方法的参数,三种方法的共同点,yield*,给Generator使用this,new,作为对象属性时的简写
                // T3: 状态机,协程,上下文,应用
                // T4: Generator 函数的异步应用
                T1() {
                    // 1.介绍:
                        // 0.可以把Generator函数理解为一个状态机,封装了多个内部状态
                        // 0.执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。
                        // 0.由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数,yield表达式就是暂停标志
                    // 2.创建及调用:
                        // 特征: 函数体内部使用yield(产出)表达式,定义不同的内部状态
                        function* helloGenerator() { // ES6没有规定星号的位置,只要在function关键字与函数名之间就行
                            yield 'hello';
                            yield 'world'; // Generator函数内部有两个yield表达式
                            return 'ending';  // 该函数有三个{{状态}}: hello, world和return语句,return用于结束函数,'ending'为最后一个状态
                        }
                        var hw = helloGenerator(); // 函数调用方法和普通函数一样,不同的是该函数并不执行,返回的也不是函数运行结果,而是一个纸箱内部状态的{{指针对象}}
                        hw.next(); // { value: 'hello', done: false }
                        hw.next(); // { value: 'world', done: false }
                        hw.next(); // { value: 'ending', done: true }
                        hw.next(); // { value: undefined, done: true }
                            // 必须调用遍历器对象的next方法让指针移动到下一个状态(不可逆)
                            // 每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止
                            // 也就是说 Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。
                    // 3.yield表达式:
                        // 1.yield在Generator中的作用
                            // 0.Generator实际上提供了可以暂停的函数,yield就是暂停标志
                            // 0.yield后面的表达式只有当调用next方法,内部指针指向该语句时才会执行,因此等于为js提供了手动的{{惰性求值}}功能
                            // 0.不用yield表达式时,就变成了一个单纯的暂缓执行函数(不会在调用函数是执行,在调用第一次next时执行)
                            // 0.yield只能用在Generator函数中,其他地方会报错
                            // 0.yield表达式如果用在另一个表达式之中，必须放在圆括号里面。
                                console.log('hello', + {yield 123})
                            // 0.yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。
                        // 2.遍历器对象的next方法逻辑如下:
                            hw.next(); 
                            // 0.遇到yield表达式,先暂停函数,然后执行紧跟在yield后面的表达式,并将值作为返回对象的value属性值,
                            // 0.下次调用next方法时继续向下执行,知道遇到下一个yield表达式,如果没有则运行到函数结束,直到return语句位置,并将return后面的表达式的值作为返回的对象的value属性值
                            // 0.如果没有return语句,则最后返回的对象value值为undefined
                    // 4.与Iterator接口的关系
                        // 由于Generator函数就是遍历器生成函数,因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。
                        // var myIterable = {};
                            myIterable[Symbol.iterator] = function* () {
                                yield 1;
                                yield 2;
                                yield 3;
                            };
                            [...myIterable] // [1, 2, 3]， 内部调用forof方法(next())
                        // Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。
                    // 5.for...of循环, 可以自动遍历Generator函数运行时生成的Iterator对象,不再需要调用next方法
                        function* foo() {
                            yield 1;
                            yield 2;
                            yield 3;
                            yield 4;
                            yield 5;
                            return 6;
                        }
                        for (let v of foo()) {
                            console.log(v); // 1 2 3 4 5, 一旦next方法返回对象的done属性为true,for...of循环就会终止,且不包含该返回对象,所以return语句返回的6不包括在for...of循环中
                        }
                },
                
                T2() {
                    // 1.原型方法
                        Generator.prototype.next
                            // 1.next方法的参数
                                // 0.yield表达式本身没有返回值,或者说总是返回undefined
                                // 0.next方法可以带一个参数,该参数就会被当做{{上一个}}yield表达式的返回值
                                // 0.由于next参数设置的是上一个yield表达式的返回值,所以第一次使用next方法传递参数是无效的,V8引擎直接忽略第一次使用next方法时的参数,只有从第二次使用next方法啊开始时参数才是有效的
                                // 0.从语义上来讲,第一个next方法用来启动遍历器对象,所以不用带参数
                                // 0.可以通过next方法的参数给Generator函数注入值,来调整函数的行为
                                // 0.如果想再第一次使用next方法时就传参可以在Generator函数外再包一层
                                function *f() {
                                    for (var i = 0; true; i++) { // 定义一个可以无限运行的Generator函数
                                        var reset = yield i;    // 如果next方法没有参数,yield的返回值总是undefined
                                        if (reset) {    // 如果next带参数reset就被赋值为该参数
                                            i = -1; 
                                            console.log(reset); 
                                        }
                                    }
                                }
                        Generator.prototype.throw; // Generator函数返回的遍历器对象都有一个throw方法,可以在函数体外抛出错误,然后再Generator函数体内捕获
                            g.throw(new Error('is error!')); // thorw方法接收一个参数,该参数会被catch语句接收,可以抛出error对象的实例
                            // 0.throw方法抛出的错误要被内部捕获前提是必须至少执行过一次next方法(第一次next相当于启动Generator函数),缶则只会抛出在函数外部
                            // 0.throw方法被捕获后会附带执行吓一跳yield表达式(即附带执行一次next方法)
                            // 0.只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。
                            // 0.多个yield表达式，可以只用一个try...catch代码块来捕获错误
                            // 1.一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了,此后再调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。
                        Generator.prototype.return; // 返回给定的值,并终结遍历Generator函数
                            g.return('d'); // {value:'d', done: true}
                            // 如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return方法会推迟到finally代码块执行完再执行。
                    // 2.next()、throw()、return() 的共同点
                        // 都是让Generator函数恢复执行,并使用不同的语句替换yield表达式
                        g.next(1); // 将yield表达式替换为一个值,如果没有参数相当于替换为undefined
                        g.throw(); // 将yield表达式替换为一个throw语句
                        g.return(); // 将yield表达式替换为一个return语句
                    // 3.yield* 表达式,自动遍历遍历器对象,相当于for...of的一种简写形式
                        // 任何数据结构只要有Iterator接口就可以被yield*遍历
                        // 在Generator函数值调用另一个Generator函数时会直接返回遍历器对象,需要手动遍历其中的值,ES6提供了yield*表达式作为解决办法
                        function* inner() {
                            yield 'hello!';
                            yield 'world!';
                        }
                        function* outer1() {
                            yield 'open';
                            yield inner(); // 返回一个遍历器对象inner
                            // yield* inner(); // 相当于把遍历器对象inner内部的所有yield表达式放在这里了
                            // yield 'hello!';
                            // yield 'world!';
                            yield 'close';
                        }
                    // 4.作为对象属性的Generator函数
                        // 如果一个对象的属性是Generator函数,可以简写为以下形式
                            let obj = {
                                * myGenerator() {}
                            }
                    // 5.Generator函数的this
                        // Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法
                            function* f() {
                                yield this.x = 2;
                            }
                            let obj = g().a; // undefined, Generator函数在this上添加了一个属性但是在它的实例里无法取到这个属性,因为Generator函数返回的总是遍历器对象而不是this对象
                            new f(); // Generator函数不能与new一起使用,会报错,因为Generator函数不是构造函数
                        // 让Generator返回一个正常的对象,拥有this,也拥有原型上的方法
                            // 生成一个空对象,然后用call方法绑定Generator函数内部的this,这样在函数调用后这个空对象就是Generator函数的实例对象了
                            // 缺点: 执行的是遍历器对象x,但生成的对象实例是obj
                            function* f() {
                                this.a = 1;
                                yield this.b = 2;
                            }
                            var obj = {};
                            var x = f.call(obj);
                            // 改进一: 将obj换成f.prototype
                            var x = f.call(f.prototype);
                            // 改进二: 把f改为构造函数,就可以使用new命令了
                            function Func() {
                                return f.call(f.prototype);
                            }
                            var fn = new Func();
                },
            
                T3() {
                    // 1.Generator与状态机
                        // Generator是实现状态机的最佳结构
                            var ticking = true;
                            var clock = function() {
                                if(ticking) 
                                    console.log('tick');
                                else 
                                    console.log('tock');
                                ticking = !ticking;
                            }
                        // 用Generator实现,少了用来保存状态的外部变量,更简洁,更安全
                        var clock = function * () {
                            while(true) {
                                console.log('tick');
                                yield;
                                console.log('tock');
                                yield;
                            }
                        }
                    // 2.Generator与协程
                        // 协程是一种程序运行的方式,可理解为'协作的线程'或'协作的函数',即可用单线程实现也能用多线程实现
                        // 0.传统的子例程采用堆栈式'后进先出'的执行方式,调用完子函数才执行父函数,只有一个栈
                        // 0.协程可多线程并行(单线程下即多函数并行),但是同一时刻只有一个线程(或函数)处于运行状态,其他线程都处于暂停状态,线程(或函数之间可以交换执行权),即一个线程(或函数)执行到一半可以暂停让另一个线程执行,协程是同时存在多个栈,但只有一个栈是在运行状态
                        // 0.js是单线程语言,只能保持一个调用栈,引入协程后每个任务可以保持自己的调用栈,这样做可以在抛出错误的时候找到原始的调用栈,不至于像异步操作的回调函数那样,一旦出错原始的调用栈早已结束
                    // 3.Generator与上下文
                        // 常规的上下文对象是以堆栈存储(作用域链)
                        // Generator函数执行产生的上下文环境一旦遇到yield命令就会暂时退出堆栈但是并不消失,里面的所有变量和对象回冻结在当前状态,等到它执行next命令时这个上下文环境又会重新加入调用栈,冻结的变量和对象恢复
                    // 4.应用
                        // 0.异步操作的同步化表达,处理异步操作,改写回调函数
                            // Generator函数的暂停执行效果意味着可以吧异步操作卸载yield表达式里,等到调用next方法时再往后执行,等同于不写回调函数
                        // 0.控制流管理
                        // 0.部署Iterator接口
                        // 0.作为数据结构
                },
                
                T4() {
                    // ES6之前异步编程的方法大概有四种: 1.回调函数; 2.事件监听; 3.发布/订阅; 4.promise对象
                        // 0.异步： 程序的执行分为两段，先执行一段，然后执行其他任务，等做好准备再执行第二段
                        // 1.回调函数: 将第二段任务单独写在一个函数里，等到重新执行这个任务的时候就直接调用这个函数
                            // node中约定回调函数的第一个参数必须是错误对象（没有则为null）原因： 第一段任务执行完毕后任务所在的上下文环境就已经结束了，在这之后抛出的错误在原来的上下文环境中已无法捕捉，只能当做参数传入第二段
                            // 缺点： 如果任务分段过多会出现多个回调函数的嵌套，不好管理，容易形成强耦合，只要有一个操作修改，其上下层回调函数可能都要改（回调地狱）
                        // 2.promise： 不是新的语法功能，而是新的写法，将回调函数的嵌套改为链式调用
                            // 缺点： 代码冗余，语义化不够强
                        // 3.Generator函数通过协程实现异步
                            // 协程：多线程互相协作完成异步任务，生成器函数实现协程是靠yield命令，它标识执行到此处执行权将交给其他协程，即yield命令是异步操作两个阶段的分界线
                            // 0.协程的Generator函数实现。整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器，异步操作需要暂停的地方都用yield语句注明
                                function* gen(x) {
                                    try{ // 在函数内部部署错误处理代码
                                        var y = yield x + 2;
                                    } catch(e) {
                                        log(e);
                                    }
                                    return y;
                                }
                                var g = gen(1); // 返回的是一个内部指针(遍历器)g, next方法的作用是分段执行Generator函数
                                g.next(); // {value:3,done: false}
                                g.next(); // {value:undefined,done: false}
                                g.throw('错误'); // 这里抛出的错误可以被gen函数内部部署的try代码块捕获,这意味着出错的代码与处理错误的代码实现了时间空间上的分离
                            // Generator 函数的数据交换和错误处理 
                                // 可以通过next方法的参数向Generator函数中注入数据
                                // Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。实现出错代码与错误处理相分离
                            // 缺点: 流程管理不方便(何时执行第一阶段,何时执行第二阶段)
                        // 4.Thunk 函数: 自动执行Generator函数的一种方法
                            // 参数的求值策略
                                // 0.传值调用: 给函数传入如(x+1)这样的参数时先计算x+1再将结果当做参数传入函数,传值较简单,但是如果函数中没有用到这个参数会造成性能损失,如c语言,js
                                // 0.传名调用: 传入表达式时先不调用,直接将表达式传入函数体,只在用到它的时候求值,如HasKell语言
                            // Thunk函数的含义: 是传名调用的一种实现策略,用来替代某个表达式
                                var thunk = function() {
                                    return x + 5;
                                }
                                function f(thunk) {
                                    return thunk() * 2;
                                }
                            // JavaScript 语言的 Thunk 函数: 将多参数函数转换为只接受一个回调函数的单参数函数(高级函数)
                            // Generator 函数的流程管理
                }
            
            
            }
        </script>

        <script class="14_async函数">
            // 就是 Generator 函数的语法糖。
            // async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。
            // T1: async函数对于Generator函数的改进
            const async = {
                T1() {
                    // 1.async函数对于Generator函数的改进
                        // 0.内置执行器,Generator函数的执行必须靠执行器,async函数自带执行器,即其执行与普通函数一样,只需要一行
                            asyncReadFile(); // 若该函数为async函数这样调用会自动执行并输出最后结果,而Generator函数要调用next方法或co模块才能真正执行
                        // 0.更好的语义
                            // async表示函数里有异步操作,await表示紧跟在后面的表达式需要等待结果
                        // 0.更广的适用性
                            // co模块约定,yield命令后面只能是Thunk函数活Promise对象
                            // async函数的await命令后面可以使Promise对象和原始类型的值(会自动转换位resolved的Promise对象)
                        // 返回值是Promise
                            // Generator函数返回的是Iterator遍历器对象,只能遍历其元素
                            // async函数返回Promise对象可以用then方法指定下一步的操作

                }
            }


        </script>
    </div>

</body>

</html>