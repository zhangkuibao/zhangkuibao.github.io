1. 使用 `&` 将多个类型合并为新的交叉类型，新类型同时拥有了其他类型的成员。
2. 使用 `|` 表示联合类型，如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。
3. 类型谓词关键字：`is`，用于进行类型保护。
4. 添加 `!` 后缀表示断定确实已赋值。
5. 用 `type` 关键字设置类型别名，起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。 
6. `keyof`， 索引类型查询操作符，对于任何类型 `T`， `keyof T` 的结果为 `T` 上已知的公共属性名的联合。
7. `T[K]`， 索引访问操作符。
8. 使用 `extends` 关键字实现接口继承
9. `implements` 关键字让类实现接口。
10. `interface` 定义接口。
11. 修饰符 `public`、`private`、`protected`。
12. `as` 模块别名。
13. `declare` 声明文件。

## 索引类型查询操作符和索引访问操作符

```ts
function pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {
  return names.map(n => o[n]);
}

interface Person {
    name: string;
    age: number;
}
let person: Person = {
    name: 'Jarid',
    age: 35
};
let strings: string[] = pluck(person, ['name']); // ok, string[]
```

1. 索引类型查询操作符 `keyof`，在这里 `keyof T` 等价于 `'name' | 'age'`。
2. 索引访问操作符 `T[K]`，在这里表示 `person['name']` 具有 `Person['name']` 类型——在上例中则是 `string` 类型，`T[K][]` 表示 `T[K]` 类型的数组。

## 映射类型
`Readonly`、`Partial`、`Pick`、`Record` 是 `TypeScript` 内置的泛型类型。
 
- 根据一个已知类型映射出一个新类型。
```ts
interface Person {
  name: string;
  age: string;
}

type Readonly<T> = {
  readonly [P in keyof T]: T[P];
}

type Partial<T> = {
  [P in keyof T]?: T[P];
}

type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
}
type Record<K extends string, T> = {
    [P in K]: T;
}

type PersonPartial = Partial<Person>;
type ReadonlyPerson = Readonly<Person>;

```